<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WorkflowPlanner - Visual Interface</title>
    
    <!-- React Flow CSS -->
    <link rel="stylesheet" href="https://unpkg.com/reactflow@11.10.4/dist/style.css">
    
    <!-- Custom CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 1rem;
            padding: 1rem;
            position: relative;
        }

        .sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .flow-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
            position: relative;
        }
        
        .bottom-bar {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem;
            display: flex;
            gap: 1rem;
            min-height: 200px;
            max-height: 300px;
        }
        
        .bottom-section {
            flex: 1;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 1rem;
            overflow-y: auto;
        }
        
        .bottom-section h3 {
            margin: 0 0 0.75rem 0;
            font-size: 1.1rem;
            color: #333;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header {
            text-align: center;
            margin-bottom: 1rem;
        }

        .header h1 {
            color: #333;
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .header p {
            color: #666;
            font-size: 0.9rem;
        }

        .input-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .input-group {
            display: flex;
            gap: 0.5rem;
        }

        input[type="text"], textarea {
            flex: 1;
            padding: 0.75rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .button {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .button-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .button-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .button-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e1e5e9;
        }

        .button-secondary:hover {
            background: #e9ecef;
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .example-select, .orchestration-select {
            padding: 0.75rem 1rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            background: #f8f9fa;
            color: #333;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
        }

        .example-select:hover, .orchestration-select:hover {
            background: #e9ecef;
        }

        .example-select:focus, .orchestration-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* New orchestration section styles */
        .orchestration-section {
            background: #f1f3f4;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #e1e5e9;
        }

        .search-container {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .search-input {
            flex: 1;
            padding: 0.6rem 0.8rem;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 0.85rem;
            background: white;
            transition: border-color 0.3s;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .orchestration-dropdown {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .dropdown-actions {
            display: flex;
            gap: 0.5rem;
        }

        .dropdown-actions .button {
            flex: 1;
            font-size: 0.8rem;
            padding: 0.5rem 0.7rem;
        }

        .button-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
        }

        .button-success:hover {
            background: linear-gradient(135deg, #218838, #1ba885);
            transform: translateY(-1px);
        }

        .button-danger {
            background: linear-gradient(135deg, #dc3545, #e74c3c);
            color: white;
            border: none;
        }

        .button-danger:hover {
            background: linear-gradient(135deg, #c82333, #dc2626);
            transform: translateY(-1px);
        }

        .button-danger:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .workflow-info {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            max-height: 400px;
            overflow-y: auto;
        }

        .workflow-info h3 {
            color: #333;
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }

        .workflow-info p {
            color: #666;
            font-size: 0.85rem;
            margin-bottom: 0.25rem;
        }

        .expandable-section {
            margin-top: 1rem;
            border-top: 1px solid #e1e5e9;
            padding-top: 1rem;
        }

        .expandable-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
            background: #e9ecef;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            transition: background 0.3s;
        }

        .expandable-header:hover {
            background: #dee2e6;
        }

        .expandable-header h4 {
            margin: 0;
            font-size: 0.9rem;
            color: #333;
        }

        .expandable-header .toggle-icon {
            transition: transform 0.3s;
        }

        .expandable-header.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        .expandable-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .expandable-content.expanded {
            max-height: 500px;
            overflow-y: auto;
        }

        .node-item, .edge-item {
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 6px;
            padding: 0.5rem;
            margin-bottom: 0.3rem;
        }

        .tool-pill {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.65rem;
            margin: 0.1rem 0.2rem 0.1rem 0;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Enhanced Results Display - Rich Panel Inspired */
        .enhanced-results {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .results-section h4 {
            color: #333;
            margin: 0 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #7DF9FF;
            font-size: 1.1rem;
        }

        .task-result-card {
            border: 2px solid #7DF9FF;
            border-radius: 8px;
            margin-bottom: 1rem;
            background: #f8feff;
            overflow: hidden;
        }

        .task-header {
            background: linear-gradient(135deg, #7DF9FF, #4ecdc4);
            color: white;
            padding: 0.75rem;
            font-weight: bold;
        }

        .agent-tools-used {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            font-weight: normal;
        }

        .agent-tools-used .tool-pill {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-size: 0.7rem;
        }

        .task-content {
            padding: 1rem;
        }

        .result-text {
            line-height: 1.6;
            color: #333;
        }

        .result-json {
            background: #f1f3f4;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 1rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            color: #333;
            overflow-x: auto;
        }

        .tool-usage-highlight {
            background: #ffeb3b;
            color: #333;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-weight: 500;
        }

        /* Tool Usage Results Panels */
        .tool-usage-panels {
            margin-top: 1rem;
        }

        .tool-usage-panel {
            border: 2px solid #00bcd4;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            background: #e0f7fa;
        }

        .tool-usage-header {
            background: #00bcd4;
            color: white;
            padding: 0.5rem;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .tool-usage-content {
            padding: 0.75rem;
        }

        .tool-args {
            color: #ff9800;
            font-family: monospace;
            font-size: 0.85rem;
            margin: 0.25rem 0;
        }

        .tool-result {
            color: #4caf50;
            font-weight: 500;
            margin: 0.25rem 0;
        }

        .tool-result::before {
            content: "✅ ";
            margin-right: 0.25rem;
        }

        /* Execution Task Enhancement */
        .execution-task {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #fafafa;
        }

        .execution-task.completed {
            border-color: #4caf50;
            background: #e8f5e8;
        }

        .execution-task.running {
            border-color: #ff9800;
            background: #fff8e1;
        }

        .execution-task.failed {
            border-color: #f44336;
            background: #ffebee;
        }

        .node-item h5, .edge-item h5 {
            margin: 0 0 0.5rem 0;
            font-size: 0.85rem;
            color: #333;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .node-item .detail-row, .edge-item .detail-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 0.25rem;
        }

        .node-item .config-box, .edge-item .condition-box {
            background: #f8f9fa;
            border: 1px solid #e1e5e9;
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.5rem;
            font-family: monospace;
            font-size: 0.7rem;
            overflow-x: auto;
        }

        .port-badge {
            display: inline-block;
            background: #e9ecef;
            color: #495057;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            margin-right: 0.25rem;
        }

        .port-badge.input {
            background: #d1ecf1;
            color: #0c5460;
        }

        .port-badge.output {
            background: #d4edda;
            color: #155724;
        }

        .status {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            display: inline-block;
        }

        .status-connected {
            background: #d4edda;
            color: #155724;
        }

        .status-disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .status-loading {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-running {
            background: #cce5ff;
            color: #004085;
        }
        
        .status-completed {
            background: #d4edda;
            color: #155724;
        }
        
        .status-failed {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-started {
            background: #e2e3e5;
            color: #383d41;
        }
        
        .execution-task {
            padding: 0.25rem 0.5rem;
            margin: 0.25rem 0;
            border-radius: 4px;
            font-size: 0.8rem;
            background: #f8f9fa;
            border-left: 3px solid #28a745;
        }
        
        .execution-task.running {
            border-left-color: #007bff;
            background: #e3f2fd;
        }
        
        .execution-task.completed {
            border-left-color: #28a745;
            background: #e8f5e8;
        }
        
        .execution-task.failed {
            border-left-color: #dc3545;
            background: #ffeaea;
        }

        .flow-container {
            width: 100%;
            height: 100%;
        }

        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            display: flex;
            gap: 0.5rem;
        }

        .control-button {
            padding: 0.5rem;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
        }

        .control-button:hover {
            background: #f8f9fa;
            transform: scale(1.05);
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            text-align: center;
            padding: 2rem;
        }

        .empty-state .icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="header">
                <h1>🌊 WorkflowPlanner</h1>
                <p>Create workflows with AI</p>
                <div id="connectionStatus" class="status status-disconnected">Disconnected</div>
            </div>

            <div class="input-section">
                <textarea 
                    id="queryInput" 
                    placeholder="Describe your workflow... (e.g., 'Fetch weather data and send it to Slack every morning')"
                    rows="4"
                ></textarea>
                
                <div class="input-group">
                    <button id="generateBtn" class="button button-primary">
                        ✨ Generate
                    </button>
                    <button id="refineBtn" class="button button-secondary" disabled>
                        🔧 Refine
                    </button>
                </div>

                <div class="input-group">
                    <select id="exampleSelect" class="example-select" style="flex: 1; margin-right: 0.5rem;">
                        <option value="">📋 Select Example...</option>
                    </select>
                    <button id="clearBtn" class="button button-secondary" disabled>
                        🗑️ Clear
                    </button>
                </div>
                
                <div class="input-group">
                    <button id="executeBtn" class="button button-primary" disabled>
                        🚀 Execute
                    </button>
                    <button id="stopBtn" class="button button-secondary" disabled>
                        ⏹️ Stop
                    </button>
                </div>

                <div class="input-group">
                    <button id="saveBtn" class="button button-success" disabled>
                        💾 Save
                    </button>
                    <button id="exportBtn" class="button button-secondary" disabled>
                        📤 Export YAML
                    </button>
                </div>
            </div>

            
            <div id="toolsSection">
                <h3>Available Tools</h3>
                <div id="toolsList" style="max-height: 200px; overflow-y: auto; font-size: 0.8rem;">
                    Loading tools...
                </div>
            </div>
        </div>

        <!-- Main Flow Area -->
        <div class="main-content">
            <div class="flow-area">
                <div class="controls">
                    <button class="control-button" onclick="fitView()">📐 Fit View</button>
                    <button class="control-button" onclick="downloadWorkflow()">💾 Download</button>
                </div>
                
                <div id="emptyState" class="empty-state">
                    <div class="icon">🌊</div>
                    <h2>Welcome to WorkflowPlanner</h2>
                    <p>Describe a workflow in the sidebar to get started,<br>or click "Example" to see a sample workflow.</p>
                </div>
                
                <div id="flowContainer" class="flow-container" style="display: none;"></div>
            </div>
            
            <!-- Bottom Bar -->
            <div id="bottomBar" class="bottom-bar" style="display: none;">
                <!-- Workflow Info Section -->
                <div class="bottom-section" id="workflowInfoSection">
                    <h3>📊 Workflow Details</h3>
                    <div style="margin-bottom: 1rem;">
                        <h4 id="workflowTitle" style="margin: 0; font-size: 1rem;">Workflow Title</h4>
                        <p id="workflowDescription" style="margin: 0.25rem 0; color: #666; font-size: 0.85rem;">Description...</p>
                        <div style="display: flex; gap: 1rem; font-size: 0.85rem; color: #333; margin-top: 0.5rem;">
                            <span><strong>Nodes:</strong> <span id="nodeCount">0</span></span>
                            <span><strong>Edges:</strong> <span id="edgeCount">0</span></span>
                            <span><strong>Rev:</strong> <span id="revNumber">1</span></span>
                        </div>
                    </div>
                    
                    <!-- Nodes List -->
                    <div style="margin-bottom: 0.75rem;">
                        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.9rem;">📦 Nodes</h4>
                        <div id="nodesList" style="max-height: 120px; overflow-y: auto;"></div>
                    </div>
                    
                    <!-- Edges List -->
                    <div>
                        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.9rem;">🔗 Edges</h4>
                        <div id="edgesList" style="max-height: 120px; overflow-y: auto;"></div>
                    </div>
                </div>
                
                <!-- Execution Status Section -->
                <div class="bottom-section" id="executionStatusSection" style="display: none;">
                    <h3>🚀 Execution Status</h3>
                    <div id="executionInfo"></div>
                    <div id="executionResults" style="display: none; margin-top: 1rem;">
                        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.9rem;">Results:</h4>
                        <div id="resultsContent" style="max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.8rem; background: white; padding: 0.5rem; border-radius: 4px; border: 1px solid #e1e5e9;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- React and React Flow -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/reactflow@11.10.4/dist/umd/index.js"></script>

    <script>
        // Global state
        let currentWorkflow = null;
        let reactFlowInstance = null;
        let ws = null;
        let currentExecution = null;
        let executionTasks = {};

        // Initialize WebSocket connection
        function initWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            console.log('🔌 Connecting to WebSocket:', wsUrl);
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('✅ WebSocket connected');
                updateConnectionStatus('connected');
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('📩 WebSocket message:', data.type, data);
                if (data.type === 'workflow_update') {
                    handleWorkflowUpdate(data.workflow);
                } else if (data.type === 'execution_update') {
                    handleExecutionUpdate(data);
                }
            };
            
            ws.onclose = function() {
                console.log('❌ WebSocket closed');
                updateConnectionStatus('disconnected');
                // Reconnect after 3 seconds
                setTimeout(initWebSocket, 3000);
            };
            
            ws.onerror = function(error) {
                console.error('❌ WebSocket error:', error);
                updateConnectionStatus('disconnected');
            };
        }

        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = `status status-${status}`;
            statusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }

        // API calls
        async function apiCall(endpoint, options = {}) {
            try {
                console.log(`Making API call to: /api${endpoint}`, options);
                const response = await fetch(`/api${endpoint}`, {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API call failed with status ${response.status}:`, errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log(`API response from /api${endpoint}:`, data);
                return data;
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }

        // Load available tools
        async function loadTools() {
            try {
                const data = await apiCall('/tools');
                const toolsList = document.getElementById('toolsList');
                
                if (data.tools && Object.keys(data.tools).length > 0) {
                    const toolsHtml = Object.entries(data.tools)
                        .slice(0, 10) // Show first 10 tools
                        .map(([name, tool]) => `
                            <div style="margin-bottom: 0.5rem; padding: 0.25rem; background: #f8f9fa; border-radius: 4px;">
                                <strong>${name}</strong><br>
                                <small>${tool.description}</small>
                            </div>
                        `).join('');
                    
                    const remaining = Object.keys(data.tools).length - 10;
                    const suffix = remaining > 0 ? `<div style="text-align: center; color: #666; margin-top: 0.5rem;">...and ${remaining} more tools</div>` : '';
                    
                    toolsList.innerHTML = toolsHtml + suffix;
                } else {
                    toolsList.innerHTML = '<div style="color: #666;">No tools available</div>';
                }
            } catch (error) {
                document.getElementById('toolsList').innerHTML = '<div style="color: #dc3545;">Failed to load tools</div>';
            }
        }

        // Workflow operations
        async function generateWorkflow() {
            const query = document.getElementById('queryInput').value.trim();
            if (!query) return;

            setLoading(true);
            try {
                const data = await apiCall('/generate', {
                    method: 'POST',
                    body: JSON.stringify({ query, refine: false })
                });
                
                if (data.success) {
                    handleWorkflowUpdate(data.workflow);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Failed to generate workflow: ' + error.message);
            } finally {
                setLoading(false);
            }
        }

        async function refineWorkflow() {
            const query = document.getElementById('queryInput').value.trim();
            if (!query || !currentWorkflow) return;

            setLoading(true);
            try {
                const data = await apiCall('/generate', {
                    method: 'POST',
                    body: JSON.stringify({ query, refine: true })
                });
                
                if (data.success) {
                    handleWorkflowUpdate(data.workflow);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Failed to refine workflow: ' + error.message);
            } finally {
                setLoading(false);
            }
        }


        async function clearWorkflow() {
            try {
                await apiCall('/clear', { method: 'POST' });
                handleWorkflowUpdate(null);
                clearExecutionStatus();
            } catch (error) {
                alert('Failed to clear workflow: ' + error.message);
            }
        }
        
        async function executeWorkflow() {
            if (!currentWorkflow) return;
            
            setExecutionLoading(true);
            try {
                const data = await apiCall('/execute', {
                    method: 'POST',
                    body: JSON.stringify({ execute_current: true })
                });
                
                if (data.success) {
                    currentExecution = {
                        id: data.execution_id,
                        status: data.status,
                        workflow_title: currentWorkflow.title
                    };
                    showExecutionStatus();
                    updateExecutionInfo();
                } else {
                    alert('Failed to start execution: ' + data.error);
                }
            } catch (error) {
                alert('Failed to execute workflow: ' + error.message);
            } finally {
                setExecutionLoading(false);
            }
        }
        
        async function stopExecution() {
            if (!currentExecution) return;
            
            try {
                await apiCall(`/executions/${currentExecution.id}`, { method: 'DELETE' });
                clearExecutionStatus();
            } catch (error) {
                alert('Failed to stop execution: ' + error.message);
            }
        }

        function setLoading(loading) {
            const generateBtn = document.getElementById('generateBtn');
            const refineBtn = document.getElementById('refineBtn');
            const exampleSelect = document.getElementById('exampleSelect');
            
            generateBtn.disabled = loading;
            refineBtn.disabled = loading || !currentWorkflow;
            exampleSelect.disabled = loading;
            
            if (loading) {
                generateBtn.innerHTML = '⏳ Generating...';
                generateBtn.classList.add('loading');
            } else {
                generateBtn.innerHTML = '✨ Generate';
                generateBtn.classList.remove('loading');
            }
        }

        // Handle workflow updates
        function handleWorkflowUpdate(workflow) {
            console.log('🔄 handleWorkflowUpdate called with:', workflow);
            currentWorkflow = workflow;
            
            if (workflow) {
                console.log('✅ Workflow received:', {
                    title: workflow.title,
                    nodes: workflow.nodes?.length || 0,
                    edges: workflow.edges?.length || 0,
                    id: workflow.id
                });
                console.log('📋 Full workflow data:', workflow);
                
                updateWorkflowInfo(workflow);
                renderWorkflow(workflow);
                showWorkflowView();
            } else {
                console.log('❌ No workflow data received');
                hideWorkflowInfo();
                showEmptyState();
            }
            
            updateButtons();
        }

        function updateWorkflowInfo(workflow) {
            document.getElementById('workflowTitle').textContent = workflow.title;
            document.getElementById('workflowDescription').textContent = workflow.description || 'No description';
            document.getElementById('nodeCount').textContent = workflow.nodes.length;
            document.getElementById('edgeCount').textContent = workflow.edges.length;
            document.getElementById('revNumber').textContent = workflow.rev;
            document.getElementById('bottomBar').style.display = 'flex';
            
            // Update nodes detail
            updateNodesDetail(workflow.nodes);
            
            // Update edges detail
            updateEdgesDetail(workflow.edges);
        }
        
        function updateNodesDetail(nodes) {
            const nodesList = document.getElementById('nodesList');
            nodesList.innerHTML = '';
            
            nodes.forEach((node, index) => {
                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'node-item';
                
                // Build ports display
                const inputPorts = (node.data.ins || []).map(p => `<span class="port-badge input">→ ${p}</span>`).join('');
                const outputPorts = (node.data.outs || []).map(p => `<span class="port-badge output">${p} →</span>`).join('');
                
                // Build config display
                let configHtml = '';
                if (node.data.config && Object.keys(node.data.config).length > 0) {
                    configHtml = `<div class="config-box">${JSON.stringify(node.data.config, null, 2)}</div>`;
                }
                
                // Build tool/agent specific info
                let specificInfo = '';
                if (node.data.tool_name) {
                    specificInfo = `<div class="detail-row"><span>Tool:</span><span>${node.data.tool_name}</span></div>`;
                } else if (node.data.agent_instructions) {
                    let toolsInfo = '';
                    if (node.data.tools && node.data.tools.length > 0) {
                        const toolPills = node.data.tools.map(tool => 
                            `<span class="tool-pill">🔧 ${tool}</span>`
                        ).join('');
                        toolsInfo = `<div style="margin: 0.5rem 0;"><div style="font-size: 0.7rem; margin-bottom: 0.25rem;">Tools:</div>${toolPills}</div>`;
                    }
                    specificInfo = `<div class="detail-row"><span>Instructions:</span></div>
                                   <div class="config-box">${node.data.agent_instructions}</div>
                                   ${toolsInfo}`;
                }
                
                nodeDiv.innerHTML = `
                    <h5 style="margin: 0 0 0.25rem 0; font-size: 0.85rem;">${getNodeIcon(node.type)} ${node.label} <span style="color: #666; font-weight: normal;">(${node.id})</span></h5>
                    <div style="font-size: 0.75rem; color: #666;">
                        ${specificInfo}
                        ${inputPorts ? `<div>Inputs: ${inputPorts}</div>` : ''}
                        ${outputPorts ? `<div>Outputs: ${outputPorts}</div>` : ''}
                    </div>
                `;
                
                nodesList.appendChild(nodeDiv);
            });
        }
        
        function updateEdgesDetail(edges) {
            const edgesList = document.getElementById('edgesList');
            edgesList.innerHTML = '';
            
            edges.forEach((edge, index) => {
                const edgeDiv = document.createElement('div');
                edgeDiv.className = 'edge-item';
                
                let conditionHtml = '';
                if (edge.data?.condition) {
                    conditionHtml = `<div class="condition-box">if: ${edge.data.condition}</div>`;
                }
                
                edgeDiv.innerHTML = `
                    <h5 style="margin: 0 0 0.25rem 0; font-size: 0.85rem;">🔗 ${edge.source} → ${edge.target}</h5>
                    <div style="font-size: 0.75rem; color: #666;">
                        ${edge.sourceHandle || edge.targetHandle ? `<div>Ports: ${edge.sourceHandle || 'default'} → ${edge.targetHandle || 'default'}</div>` : ''}
                        ${conditionHtml}
                    </div>
                `;
                
                edgesList.appendChild(edgeDiv);
            });
        }
        

        function updateButtons() {
            const buttons = ['refineBtn', 'clearBtn', 'executeBtn', 'saveBtn', 'exportBtn'];
            
            buttons.forEach(buttonId => {
                const button = document.getElementById(buttonId);
                if (button) {
                    button.disabled = !currentWorkflow;
                } else {
                    console.warn(`Button ${buttonId} not found`);
                }
            });
        }
        
        function setExecutionLoading(loading) {
            const executeBtn = document.getElementById('executeBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            executeBtn.disabled = loading || !currentWorkflow;
            stopBtn.disabled = !currentExecution;
            
            if (loading) {
                executeBtn.innerHTML = '⏳ Starting...';
            } else {
                executeBtn.innerHTML = '🚀 Execute';
            }
        }
        
        function handleExecutionUpdate(data) {
            console.log('🔄 Execution update:', data);
            
            if (!currentExecution || currentExecution.id !== data.execution_id) {
                console.log('Ignoring update for unknown execution');
                return;
            }
            
            currentExecution.status = data.status;
            
            if (data.results) {
                currentExecution.results = data.results;
                
                // Handle task-level updates
                if (data.results.current_task) {
                    const taskName = data.results.current_task;
                    const taskStatus = data.results.status;
                    const taskResult = data.results.result;
                    
                    if (!executionTasks[taskName]) {
                        executionTasks[taskName] = {};
                    }
                    
                    executionTasks[taskName].status = taskStatus;
                    if (taskResult !== undefined) {
                        executionTasks[taskName].result = taskResult;
                    }
                    
                    updateTaskDisplay(taskName, taskStatus, taskResult);
                }
            }
            
            if (data.error) {
                currentExecution.error = data.error;
            }
            
            updateExecutionInfo();
            
            // Show results if completed
            if (data.status === 'completed' && data.results) {
                showExecutionResults(data.results);
            }
            
            // Handle completion or failure
            if (data.status === 'completed' || data.status === 'failed') {
                setExecutionLoading(false);
                document.getElementById('stopBtn').disabled = true;
            }
        }
        
        function showExecutionStatus() {
            document.getElementById('executionStatusSection').style.display = 'block';
        }
        
        function clearExecutionStatus() {
            currentExecution = null;
            executionTasks = {};
            document.getElementById('executionStatusSection').style.display = 'none';
            document.getElementById('executionResults').style.display = 'none';
            document.getElementById('stopBtn').disabled = true;
        }
        
        function updateExecutionInfo() {
            if (!currentExecution) return;
            
            const statusClass = `status-${currentExecution.status}`;
            const statusText = currentExecution.status.charAt(0).toUpperCase() + currentExecution.status.slice(1);
            
            let infoHTML = `
                <div class="detail-row">
                    <span>Status:</span>
                    <span class="status ${statusClass}">${statusText}</span>
                </div>
                <div class="detail-row">
                    <span>Execution ID:</span>
                    <span style="font-family: monospace; font-size: 0.8em;">${currentExecution.id}</span>
                </div>
                <div class="detail-row">
                    <span>Workflow:</span>
                    <span>${currentExecution.workflow_title}</span>
                </div>
            `;
            
            if (currentExecution.error) {
                infoHTML += `
                    <div class="detail-row" style="margin-top: 0.5rem;">
                        <span style="color: #dc3545; font-weight: bold;">Error:</span>
                    </div>
                    <div style="background: #f8d7da; color: #721c24; padding: 0.5rem; border-radius: 4px; margin-top: 0.25rem; font-size: 0.8rem;">
                        ${currentExecution.error}
                    </div>
                `;
            }
            
            // Add task progress with enhanced tool usage display
            if (Object.keys(executionTasks).length > 0) {
                infoHTML += '<div style="margin-top: 1rem;"><h4 style="margin: 0 0 0.5rem 0; font-size: 0.9rem;">📋 Task Progress:</h4>';
                for (const [taskName, task] of Object.entries(executionTasks)) {
                    const taskClass = task.status === 'completed' ? 'completed' : 
                                     task.status === 'started' ? 'running' : 
                                     task.status === 'failed' ? 'failed' : '';
                    
                    // Get task node info for enhanced display
                    const taskNode = currentWorkflow?.nodes?.find(n => n.id === taskName);
                    const isAgentTask = taskNode?.type === 'agent';
                    const agentTools = taskNode?.data?.tools || [];
                    const taskIcon = isAgentTask ? '🤖' : '🔧';
                    
                    infoHTML += `<div class="execution-task ${taskClass}">`;
                    infoHTML += `<strong>${taskIcon} ${taskName}</strong>: ${task.status}`;
                    
                    // Show available tools for agent tasks
                    if (isAgentTask && agentTools.length > 0) {
                        const toolPills = agentTools.map(tool => `<span class="tool-pill" style="font-size: 0.6rem; padding: 0.1rem 0.3rem;">🔧 ${tool}</span>`).join('');
                        infoHTML += `<div style="margin-top: 0.25rem;">${toolPills}</div>`;
                    }
                    
                    // Show result if available
                    if (task.result !== undefined) {
                        if (typeof task.result === 'object' && task.result !== null && task.result.tool_usage_results) {
                            // Show summary of tool usage results
                            const toolCount = task.result.tool_usage_results.length;
                            infoHTML += `<br><small style="color: #00bcd4;">🛠️ Used ${toolCount} tool${toolCount !== 1 ? 's' : ''}</small>`;
                        } else if (typeof task.result === 'string') {
                            const truncatedResult = task.result.length > 100 ? task.result.substring(0, 100) + '...' : task.result;
                            infoHTML += `<br><small>→ ${truncatedResult}</small>`;
                        } else {
                            infoHTML += `<br><small>→ ${JSON.stringify(task.result)}</small>`;
                        }
                    }
                    
                    infoHTML += '</div>';
                }
                infoHTML += '</div>';
            }
            
            document.getElementById('executionInfo').innerHTML = infoHTML;
        }
        
        function updateTaskDisplay(taskName, status, result) {
            // This is called for real-time task updates
            console.log(`📋 Task Update: ${taskName} - ${status}`, result);
            updateExecutionInfo(); // Refresh the entire display
        }
        
        function showExecutionResults(results) {
            const resultsDiv = document.getElementById('executionResults');
            const resultsContent = document.getElementById('resultsContent');
            
            let resultsHTML = '';
            
            // Enhanced results display with tool usage highlighting
            if (results.results && typeof results.results === 'object') {
                resultsHTML = '<div class="enhanced-results">';
                
                // Show workflow summary
                resultsHTML += '<div class="results-section"><h4>🎯 Workflow Results</h4>';
                
                // Process each task result
                for (const [taskKey, taskResult] of Object.entries(results.results)) {
                    const taskNode = currentWorkflow?.nodes?.find(n => n.id === taskKey);
                    const isAgentTask = taskNode?.type === 'agent';
                    const agentTools = taskNode?.data?.tools || [];
                    
                    resultsHTML += '<div class="task-result-card">';
                    
                    // Task header with icon and tools if available
                    const taskIcon = isAgentTask ? '🤖' : '🔧';
                    let taskHeader = `${taskIcon} <strong>${taskKey}</strong>`;
                    
                    if (isAgentTask && agentTools.length > 0) {
                        const toolPills = agentTools.map(tool => `<span class="tool-pill">🔧 ${tool}</span>`).join('');
                        taskHeader += `<div class="agent-tools-used">Tools Available: ${toolPills}</div>`;
                    }
                    
                    resultsHTML += `<div class="task-header">${taskHeader}</div>`;
                    
                    // Task result content
                    resultsHTML += '<div class="task-content">';
                    
                    // Check if this is an agent result with tool usage results
                    if (typeof taskResult === 'object' && taskResult !== null) {
                        // Handle structured agent result with potential tool usage
                        const agentOutput = taskResult.result || taskResult.output || taskResult;
                        const toolUsageResults = taskResult.tool_usage_results;
                        
                        // Display main agent output
                        if (typeof agentOutput === 'string') {
                            let displayResult = agentOutput;
                            
                            if (isAgentTask && agentTools.length > 0) {
                                // Highlight potential tool usage in agent responses (only once per term)
                                const highlightedTerms = new Set();
                                agentTools.forEach(tool => {
                                    if (!highlightedTerms.has(tool.toLowerCase())) {
                                        const toolPattern = new RegExp(`\\b(${tool})\\b`, 'gi');
                                        displayResult = displayResult.replace(toolPattern, '<mark class="tool-usage-highlight">$1</mark>');
                                        highlightedTerms.add(tool.toLowerCase());
                                    }
                                });
                            }
                            
                            resultsHTML += `<div class="result-text">${displayResult}</div>`;
                        } else {
                            resultsHTML += `<pre class="result-json">${JSON.stringify(agentOutput, null, 2)}</pre>`;
                        }
                        
                        // Display tool usage results in Rich panel style
                        if (toolUsageResults && Array.isArray(toolUsageResults) && toolUsageResults.length > 0) {
                            resultsHTML += '<div class="tool-usage-panels">';
                            resultsHTML += '<h5 style="margin: 1rem 0 0.5rem 0; color: #333;">🛠️ Tool Usage Results</h5>';
                            
                            toolUsageResults.forEach((toolUsage, index) => {
                                resultsHTML += '<div class="tool-usage-panel">';
                                resultsHTML += `<div class="tool-usage-header">🛠️ ${toolUsage.tool_name}</div>`;
                                resultsHTML += '<div class="tool-usage-content">';
                                
                                // Show tool arguments
                                if (toolUsage.tool_args && Object.keys(toolUsage.tool_args).length > 0) {
                                    resultsHTML += '<div><strong>Arguments:</strong></div>';
                                    resultsHTML += `<div class="tool-args">${JSON.stringify(toolUsage.tool_args, null, 2)}</div>`;
                                }
                                
                                // Show tool result
                                if (toolUsage.tool_result !== undefined && toolUsage.tool_result !== null) {
                                    resultsHTML += '<div><strong>Result:</strong></div>';
                                    if (typeof toolUsage.tool_result === 'string') {
                                        resultsHTML += `<div class="tool-result">${toolUsage.tool_result}</div>`;
                                    } else {
                                        resultsHTML += `<div class="tool-result"><pre>${JSON.stringify(toolUsage.tool_result, null, 2)}</pre></div>`;
                                    }
                                }
                                
                                resultsHTML += '</div>'; // tool-usage-content
                                resultsHTML += '</div>'; // tool-usage-panel
                            });
                            
                            resultsHTML += '</div>'; // tool-usage-panels
                        }
                    } else if (typeof taskResult === 'string') {
                        // Simple string result
                        let displayResult = taskResult;
                        
                        if (isAgentTask && agentTools.length > 0) {
                            // Highlight potential tool usage in agent responses (only once per term)
                            const highlightedTerms = new Set();
                            agentTools.forEach(tool => {
                                if (!highlightedTerms.has(tool.toLowerCase())) {
                                    const toolPattern = new RegExp(`\\b(${tool})\\b`, 'gi');
                                    displayResult = displayResult.replace(toolPattern, '<mark class="tool-usage-highlight">$1</mark>');
                                    highlightedTerms.add(tool.toLowerCase());
                                }
                            });
                        }
                        
                        resultsHTML += `<div class="result-text">${displayResult}</div>`;
                    } else {
                        // Fallback to JSON display
                        resultsHTML += `<pre class="result-json">${JSON.stringify(taskResult, null, 2)}</pre>`;
                    }
                    
                    resultsHTML += '</div>'; // task-content
                    resultsHTML += '</div>'; // task-result-card
                }
                
                resultsHTML += '</div>'; // results-section
                resultsHTML += '</div>'; // enhanced-results
            } else {
                // Fallback to original JSON display
                const jsonString = results.results ? JSON.stringify(results.results, null, 2) : JSON.stringify(results, null, 2);
                resultsHTML = `<pre class="result-json">${jsonString}</pre>`;
            }
            
            resultsContent.innerHTML = resultsHTML;
            resultsDiv.style.display = 'block';
        }

        function showEmptyState() {
            document.getElementById('emptyState').style.display = 'flex';
            document.getElementById('flowContainer').style.display = 'none';
        }

        function showWorkflowView() {
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('flowContainer').style.display = 'block';
        }

        // React Flow state management
        let currentNodes = [];
        let currentEdges = [];
        
        // React Flow rendering
        function renderWorkflow(workflow) {
            console.log('🎨 renderWorkflow called with:', workflow);
            const container = document.getElementById('flowContainer');
            
            // Convert workflow to React Flow format
            console.log('🔄 Converting nodes:', workflow.nodes);
            currentNodes = workflow.nodes.map((node, index) => {
                // Create label with tool pills for agent nodes
                let nodeLabel = `${getNodeIcon(node.type)} ${node.label}`;
                let toolsInfo = '';
                
                if (node.type === 'agent' && node.data.tools && node.data.tools.length > 0) {
                    const toolPills = node.data.tools.map(tool => `🔧${tool}`).join(' ');
                    toolsInfo = `\\n${toolPills}`;
                }
                
                const reactFlowNode = {
                    id: node.id,
                    type: 'default',
                    position: node.position || { x: index * 250, y: index * 100 },
                    data: {
                        label: nodeLabel + toolsInfo,
                    },
                    draggable: true,  // Explicitly enable dragging per node
                    selectable: true, // Explicitly enable selection per node
                    style: {
                        background: getNodeColor(node.type),
                        color: 'white',
                        border: '2px solid #333',
                        borderRadius: '10px',
                        padding: '10px',
                        fontSize: '12px',
                        fontWeight: 'bold',
                        cursor: 'grab', // Add grab cursor to indicate draggable
                        minWidth: node.type === 'agent' && node.data.tools ? '180px' : '120px', // Wider for agent nodes with tools
                        minHeight: node.type === 'agent' && node.data.tools ? '80px' : '60px',
                        whiteSpace: 'pre-line', // Allow line breaks in labels
                    }
                };
                console.log(`   Node ${index}: ${node.id} -> ReactFlow node:`, reactFlowNode);
                return reactFlowNode;
            });

            console.log('🔄 Converting edges:', workflow.edges);
            currentEdges = workflow.edges.map((edge, index) => {
                const reactFlowEdge = {
                    id: edge.id,
                    source: edge.source,
                    target: edge.target,
                    sourceHandle: edge.sourceHandle,
                    targetHandle: edge.targetHandle,
                    label: edge.data?.condition ? `if: ${edge.data.condition}` : '',
                    style: { stroke: '#333', strokeWidth: 2 },
                    labelStyle: { fontSize: '10px', fill: '#666' },
                    labelBgStyle: { fill: 'white', fillOpacity: 0.8 },
                };
                console.log(`   Edge ${index}: ${edge.source} -> ${edge.target}:`, reactFlowEdge);
                return reactFlowEdge;
            });

            console.log('📊 Final ReactFlow data:', { currentNodes, currentEdges });

            // Check if ReactFlow is available
            if (typeof ReactFlow === 'undefined') {
                console.error('ReactFlow not loaded properly');
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #666;">React Flow failed to load. Please refresh the page.</div>';
                return;
            }

            console.log('ReactFlow object:', ReactFlow);

            // Create React Flow component using React.createElement
            // Use the hooks from ReactFlow
            const { ReactFlowProvider, applyNodeChanges, applyEdgeChanges } = ReactFlow;
            const ReactFlowComponent = ReactFlow.default || ReactFlow.ReactFlow;
            
            console.log('Using ReactFlow component:', ReactFlowComponent);
            console.log('ReactFlow hooks available:', { ReactFlowProvider, applyNodeChanges, applyEdgeChanges });
            
            if (!ReactFlowComponent) {
                console.error('ReactFlow component not found!');
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #dc3545;">ReactFlow failed to load. Check console for details.</div>';
                return;
            }
            
            // Create a controlled component that manages nodes/edges state
            const FlowApp = function() {
                const [nodes, setNodes] = React.useState(currentNodes);
                const [edges, setEdges] = React.useState(currentEdges);
                
                const onNodesChange = React.useCallback((changes) => {
                    setNodes((nds) => {
                        const updated = applyNodeChanges(changes, nds);
                        console.log('Nodes updated:', changes);
                        return updated;
                    });
                }, []);
                
                const onEdgesChange = React.useCallback((changes) => {
                    setEdges((eds) => applyEdgeChanges(changes, eds));
                }, []);
                
                const onConnect = React.useCallback((connection) => {
                    console.log('New connection:', connection);
                }, []);
                
                const onInit = React.useCallback((instance) => {
                    reactFlowInstance = instance;
                    console.log('ReactFlow initialized with instance:', instance);
                    console.log('fitView available:', typeof instance.fitView);
                    // Fit view after initialization
                    setTimeout(() => instance.fitView({ padding: 0.1 }), 100);
                }, []);
                
                const onNodeDragStart = React.useCallback((event, node) => {
                    console.log('Node drag started:', node.id);
                }, []);
                
                const onNodeDrag = React.useCallback((event, node) => {
                    console.log('Node dragging:', node.id, node.position);
                }, []);
                
                const onNodeDragStop = React.useCallback((event, node) => {
                    console.log('Node drag stopped:', node.id, node.position);
                }, []);
                
                return React.createElement(ReactFlowComponent, {
                    nodes: nodes,
                    edges: edges,
                    onNodesChange: onNodesChange,
                    onEdgesChange: onEdgesChange,
                    onConnect: onConnect,
                    onInit: onInit,
                    onNodeDragStart: onNodeDragStart,
                    onNodeDrag: onNodeDrag,
                    onNodeDragStop: onNodeDragStop,
                    nodesDraggable: true,
                    nodesConnectable: true,
                    elementsSelectable: true,
                    panOnDrag: [1, 2], // Left or middle mouse button
                    selectionOnDrag: false,
                    zoomOnScroll: true,
                    zoomOnPinch: true,
                    zoomOnDoubleClick: true,
                    preventScrolling: true,
                    fitView: false,
                    attributionPosition: 'bottom-left',
                    defaultViewport: { x: 0, y: 0, zoom: 1 }
                });
            };

            // Wrap in ReactFlowProvider for proper functionality
            console.log('Creating wrapped component with provider...');
            
            let AppComponent;
            if (ReactFlowProvider) {
                // Wrap the flow component in provider
                AppComponent = React.createElement(ReactFlowProvider, {},
                    React.createElement(FlowApp)
                );
                console.log('Created component with ReactFlowProvider');
            } else {
                // Use without provider if not available
                AppComponent = React.createElement(FlowApp);
                console.log('Created component without provider');
            }
            
            // Render to DOM
            try {
                const root = ReactDOM.createRoot ? ReactDOM.createRoot(container) : null;
                if (root) {
                    root.render(AppComponent);
                } else {
                    ReactDOM.render(AppComponent, container);
                }
                console.log('Workflow rendered successfully with controlled state management');
            } catch (error) {
                console.error('Error rendering workflow:', error);
                container.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">Error rendering workflow: ${error.message}</div>`;
            }
        }

        function getNodeIcon(type) {
            const icons = {
                'tool': '🔧',
                'agent': '🤖',
                'workflow_call': '📞',
                'decision': '🤔'
            };
            return icons[type] || '⚙️';
        }

        function getNodeColor(type) {
            const colors = {
                'tool': '#ff6b6b',
                'agent': '#4ecdc4',
                'workflow_call': '#45b7d1',
                'decision': '#f39c12'
            };
            return colors[type] || '#95a5a6';
        }

        // Utility functions
        function fitView() {
            if (reactFlowInstance) {
                console.log('Fitting view with instance:', reactFlowInstance);
                reactFlowInstance.fitView({ padding: 0.2, duration: 800 });
            } else {
                console.log('ReactFlow instance not available yet');
            }
        }

        function downloadWorkflow() {
            if (!currentWorkflow) return;
            
            const dataStr = JSON.stringify(currentWorkflow, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `${currentWorkflow.title.replace(/\s+/g, '_')}.json`;
            link.click();
        }

        // Example workflows functions
        async function loadExamples() {
            try {
                const response = await fetch('/api/workflows/combined');
                const data = await response.json();
                
                const selectElement = document.getElementById('exampleSelect');
                
                // Clear existing options except the first one
                selectElement.innerHTML = '<option value="">📋 Select Example...</option>';
                
                // Add example options (both examples and saved)
                Object.entries(data.examples).forEach(([key, example]) => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = `📋 ${example.title} (${example.node_count} nodes)`;
                    option.title = example.description;
                    option.dataset.source = 'example';
                    selectElement.appendChild(option);
                });
                
                // Add saved workflows
                Object.entries(data.saved).forEach(([key, workflow]) => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = `💾 ${workflow.title} (${workflow.node_count} nodes)`;
                    option.title = workflow.description;
                    option.dataset.source = 'saved';
                    selectElement.appendChild(option);
                });
                
                console.log('✅ Loaded examples:', {
                    examples: Object.keys(data.examples).length,
                    saved: Object.keys(data.saved).length
                });
            } catch (error) {
                console.error('❌ Error loading examples:', error);
            }
        }
        
        async function loadSelectedExample() {
            const selectElement = document.getElementById('exampleSelect');
            const selectedValue = selectElement.value;
            
            if (!selectedValue) {
                return; // No selection made
            }
            
            try {
                setLoading(true);
                console.log('📋 Loading workflow:', selectedValue);
                
                const isExample = selectElement.options[selectElement.selectedIndex].dataset.source === 'example';
                
                let response;
                if (isExample) {
                    response = await fetch(`/api/example/${selectedValue}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                } else {
                    response = await fetch(`/api/workflows/load/${selectedValue}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('📦 Received workflow data:', data);
                
                if (data.workflow) {
                    console.log('🔄 Updating workflow with data');
                    
                    // Use the same function that handles AI-generated workflows
                    handleWorkflowUpdate(data.workflow);
                    
                    // Reset dropdown to placeholder
                    selectElement.value = '';
                    
                    console.log('✅ Workflow loaded:', data.workflow.title);
                } else {
                    console.error('❌ No workflow in response:', data);
                    alert('Failed to load workflow: No workflow data received');
                }
            } catch (error) {
                console.error('❌ Error loading workflow:', error);
                alert('Failed to load workflow: ' + error.message);
            } finally {
                setLoading(false);
            }
        }
        
        // Delete workflow functionality removed - can be added to a separate UI later
        
        async function saveCurrentWorkflow() {
            if (!currentWorkflow) {
                alert('No workflow to save');
                return;
            }
            
            const name = prompt('Enter a name for this workflow:', currentWorkflow.title || 'My Workflow');
            if (!name) return;
            
            const description = prompt('Enter a description (optional):', currentWorkflow.description || '');
            const tagsInput = prompt('Enter tags (comma-separated, optional):', '');
            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];
            
            try {
                setLoading(true);
                
                const response = await fetch('/api/workflows/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, description, tags })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('✅ Workflow saved:', data.workflow_id);
                    alert(`Workflow "${name}" saved successfully!`);
                    await loadExamples(); // Refresh the list
                } else {
                    throw new Error(data.error || 'Save failed');
                }
            } catch (error) {
                console.error('❌ Error saving workflow:', error);
                alert('Failed to save workflow: ' + error.message);
            } finally {
                setLoading(false);
            }
        }
        
        async function exportCurrentWorkflowYAML() {
            if (!currentWorkflow) {
                alert('No workflow to export');
                return;
            }
            
            try {
                // Generate YAML from current workflow
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        query: 'export current workflow as yaml',
                        refine: false 
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to generate YAML export');
                }
                
                // For now, just download the workflow as JSON
                // TODO: Add proper YAML export endpoint
                const workflowName = currentWorkflow.title?.replace(/[^a-z0-9]/gi, '_') || 'workflow';
                const dataStr = JSON.stringify(currentWorkflow, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `${workflowName}.json`;
                link.click();
                
                console.log('✅ Workflow exported');
            } catch (error) {
                console.error('❌ Error exporting workflow:', error);
                alert('Failed to export workflow: ' + error.message);
            }
        }

        // Event listeners
        document.getElementById('generateBtn').addEventListener('click', generateWorkflow);
        document.getElementById('refineBtn').addEventListener('click', refineWorkflow);
        document.getElementById('exampleSelect').addEventListener('change', loadSelectedExample);
        document.getElementById('clearBtn').addEventListener('click', clearWorkflow);
        document.getElementById('executeBtn').addEventListener('click', executeWorkflow);
        document.getElementById('stopBtn').addEventListener('click', stopExecution);
        document.getElementById('saveBtn').addEventListener('click', saveCurrentWorkflow);
        document.getElementById('exportBtn').addEventListener('click', exportCurrentWorkflowYAML);

        document.getElementById('queryInput').addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'Enter') {
                if (currentWorkflow) {
                    refineWorkflow();
                } else {
                    generateWorkflow();
                }
            }
        });

        // Debug function to check loaded libraries
        function debugLibraries() {
            console.log('=== Library Debug ===');
            console.log('React:', typeof React);
            console.log('ReactDOM:', typeof ReactDOM);
            console.log('ReactFlow:', typeof ReactFlow);
            console.log('window.ReactFlow:', typeof window.ReactFlow);
            if (typeof ReactFlow !== 'undefined') {
                console.log('ReactFlow keys:', Object.keys(ReactFlow));
                console.log('ReactFlow.default:', typeof ReactFlow.default);
                console.log('ReactFlow.ReactFlow:', typeof ReactFlow.ReactFlow);
                console.log('applyNodeChanges:', typeof ReactFlow.applyNodeChanges);
                console.log('applyEdgeChanges:', typeof ReactFlow.applyEdgeChanges);
            }
            console.log('==================');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 DOM loaded, initializing...');
            debugLibraries();
            initWebSocket();
            loadTools();
            loadExamples();
            updateButtons();
            console.log('✅ Initialization complete');
        });
    </script>
</body>
</html>