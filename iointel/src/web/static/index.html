<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WorkflowPlanner - Visual Interface</title>
    <!-- Cache busting for updates -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    
    <!-- React Flow CSS -->
    <link rel="stylesheet" href="https://unpkg.com/reactflow@11.10.4/dist/style.css">
    
    <!-- Custom CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f0f1a;
            height: 100vh;
            overflow: hidden;
            color: #e0e0e0;
        }

        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            grid-template-rows: 1fr;
            gap: 1rem;
            height: 100vh;
            width: 100vw;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            overflow: hidden;
            padding: 1rem;
            box-sizing: border-box;
        }

        /* Chat Sidebar */
        .chat-panel {
            grid-row: 1 / -1;
            grid-column: 1;
            background: rgba(20, 20, 35, 0.95);
            border-radius: 20px;
            border: 1px solid rgba(100, 255, 100, 0.3);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4), 
                0 0 25px rgba(138, 43, 226, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(135deg, #ff6b35 0%, #f7941d 100%);
            padding: 1rem;
            border-radius: 20px 20px 0 0;
            color: #0f0f1a;
            font-weight: bold;
            text-align: center;
            font-size: 1.2rem;
        }

        /* Session Controls */
        .session-controls {
            padding: 0.75rem 1rem;
            background: rgba(30, 30, 45, 0.6);
            border-bottom: 1px solid rgba(255, 130, 40, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .session-info {
            color: #b8b8b8;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .session-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .session-btn {
            background: rgba(255, 130, 40, 0.1);
            border: 1px solid rgba(255, 130, 40, 0.3);
            color: #ff6b35;
            padding: 0.35rem 0.7rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .session-btn:hover {
            background: rgba(255, 130, 40, 0.2);
            border-color: #ff6b35;
            box-shadow: 0 2px 8px rgba(255, 130, 40, 0.3);
        }

        .session-btn.active {
            background: #ff6b35;
            color: #0f0f1a;
            font-weight: bold;
        }

        .session-btn.secondary {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.2);
            color: #c0c0c0;
        }

        .session-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .chat-input-container {
            padding: 1rem;
            border-top: 1px solid rgba(255, 130, 40, 0.3);
            background: rgba(30, 30, 45, 0.8);
        }

        .chat-input {
            width: 100%;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 130, 40, 0.3);
            border-radius: 10px;
            color: #e0e0e0;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .chat-input:focus {
            outline: none;
            border-color: #ff6b35;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 2px rgba(255, 130, 40, 0.2);
        }

        /* Main Content Area */
        .main-content {
            grid-column: 2;
            grid-row: 1;
            display: flex;
            flex-direction: column;
            gap: 0;
            position: relative;
            height: 100%;
            overflow: hidden;
        }
        
        .flow-area {
            flex: 1 1 auto;
            background: rgba(20, 20, 35, 0.95);
            border-radius: 20px 20px 0 0;
            border: 1px solid rgba(100, 255, 100, 0.3);
            border-bottom: none;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(138, 43, 226, 0.18);
            overflow: hidden;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 200px;
        }
        
        /* Panel Resizer */
        .panel-resizer {
            height: 12px;
            background: transparent;
            cursor: ns-resize;
            position: relative;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            user-select: none;
            flex-shrink: 0;
        }
        
        .panel-resizer::before {
            content: '';
            width: 80px;
            height: 3px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(100, 255, 100, 0.3) 20%, 
                rgba(100, 255, 100, 0.6) 50%, 
                rgba(100, 255, 100, 0.3) 80%, 
                transparent 100%);
            border-radius: 2px;
            transition: all 0.2s ease;
        }
        
        .panel-resizer:hover::before {
            height: 4px;
            width: 120px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 130, 40, 0.5) 20%, 
                #ff6b35 50%, 
                rgba(255, 130, 40, 0.5) 80%, 
                transparent 100%);
            box-shadow: 0 0 20px rgba(255, 130, 40, 0.8);
        }
        
        .panel-resizer.dragging::before {
            height: 5px;
            width: 150px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                #64FF64 20%, 
                #64FF64 50%, 
                #64FF64 80%, 
                transparent 100%);
            box-shadow: 0 0 30px #64FF64;
        }
        
        /* Bottom Panel - Enhanced Theme */
        .bottom-panel {
            background: linear-gradient(135deg, 
                rgba(20, 20, 35, 0.95) 0%, 
                rgba(10, 10, 20, 0.98) 50%, 
                rgba(20, 20, 35, 0.95) 100%);
            border: 1px solid rgba(100, 255, 100, 0.3);
            border-top: 2px solid rgba(255, 130, 40, 0.5);
            border-radius: 0 0 20px 20px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 
                0 -4px 20px rgba(255, 130, 40, 0.2),
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            height: 350px;
            flex-shrink: 0;
            transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .bottom-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                #ff6b35 50%, 
                transparent 100%);
            opacity: 0.6;
            animation: glow-pulse 3s ease-in-out infinite;
        }
        
        @keyframes glow-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }
        
        .bottom-section {
            background: rgba(30, 30, 45, 0.4);
            padding: 1.5rem;
            overflow-y: auto;
            position: relative;
            flex: 1;
            max-height: calc(100vh - 200px); /* Ensure scrolling works */
            scrollbar-width: thin;
            scrollbar-color: rgba(100, 255, 100, 0.5) transparent;
        }
        
        .bottom-section::-webkit-scrollbar {
            width: 8px;
        }
        
        .bottom-section::-webkit-scrollbar-track {
            background: rgba(100, 255, 100, 0.1);
            border-radius: 4px;
        }
        
        .bottom-section::-webkit-scrollbar-thumb {
            background: rgba(100, 255, 100, 0.5);
            border-radius: 4px;
        }
        
        .bottom-section::-webkit-scrollbar-thumb:hover {
            background: rgba(100, 255, 100, 0.7);
        }
        
        .bottom-section:not(:last-child)::after {
            content: '';
            position: absolute;
            right: 0;
            top: 10%;
            bottom: 10%;
            width: 1px;
            background: linear-gradient(to bottom, transparent, rgba(255, 130, 40, 0.5), transparent);
        }
        
        .bottom-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1.2rem;
            color: #ff6b35;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Message Bubbles */
        .message {
            max-width: 80%;
            word-wrap: break-word;
        }

        .message.user {
            align-self: flex-end;
        }

        .message.assistant {
            align-self: flex-start;
        }

        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 15px;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .message.user .message-bubble {
            background: linear-gradient(135deg, #ff6b35 0%, #f7941d 100%);
            color: #0f0f1a;
            border-bottom-right-radius: 5px;
        }

        .message.assistant .message-bubble {
            background: rgba(50, 50, 70, 0.8);
            color: #e0e0e0;
            border-bottom-left-radius: 5px;
        }
        
        .message-bubble strong {
            color: #ff6b35;
            font-weight: 600;
        }
        
        .message-bubble em {
            font-style: italic;
            color: #a0d8ff;
        }
        
        .message-bubble code {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #ff6b35;
        }
        
        .message-bubble pre {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 8px 0;
        }
        
        .message-bubble pre code {
            background: none;
            padding: 0;
        }
        
        .message-bubble h2, .message-bubble h3, .message-bubble h4 {
            color: #ff6b35;
            margin: 12px 0 8px 0;
            font-weight: 600;
        }
        
        .message-bubble h2 {
            font-size: 1.3em;
        }
        
        .message-bubble h3 {
            font-size: 1.2em;
        }
        
        .message-bubble h4 {
            font-size: 1.1em;
        }
        
        .message-bubble ul, .message-bubble ol {
            margin: 8px 0;
            padding-left: 24px;
        }
        
        .message-bubble li {
            margin: 4px 0;
            line-height: 1.5;
        }
        
        .message-bubble p {
            margin: 8px 0;
            line-height: 1.5;
        }
        
        .message-bubble p:first-child {
            margin-top: 0;
        }
        
        .message-bubble p:last-child {
            margin-bottom: 0;
        }
        
        /* System message styling for execution reports */
        .message.system .message-bubble {
            background: linear-gradient(135deg, rgba(40, 40, 60, 0.95), rgba(30, 30, 50, 0.95));
            border: 1px solid rgba(255, 130, 40, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
        }
        
        .message.system .message-bubble h2,
        .message.system .message-bubble h3 {
            color: #FFD700;
            margin: 8px 0;
        }

        .message-time {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-top: 0.25rem;
        }

        /* Header */
        .header {
            display: none;
        }

        .header p {
            color: #666;
            font-size: 0.9rem;
        }

        /* Tool Search */
        .tool-search-container {
            position: relative;
            margin-bottom: 1rem;
        }

        .tool-search {
            width: 100%;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 130, 40, 0.3);
            border-radius: 10px;
            color: #e0e0e0;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .tool-search:focus {
            outline: none;
            border-color: #ff6b35;
            background: rgba(255, 255, 255, 0.15);
        }

        .tool-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 0.5rem;
            background: rgba(30, 30, 45, 0.98);
            border: 1px solid rgba(255, 130, 40, 0.3);
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .tool-result-item {
            padding: 0.75rem;
            border-bottom: 1px solid rgba(255, 130, 40, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tool-result-item:hover {
            background: rgba(255, 130, 40, 0.1);
        }

        .tool-result-name {
            color: #ff6b35;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .tool-result-desc {
            font-size: 0.85rem;
            color: #a0a0a0;
        }

        /* Buttons */
        .button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 130, 40, 0.2);
            color: #ff6b35;
            border: 1px solid rgba(255, 130, 40, 0.3);
        }

        .button:hover:not(:disabled) {
            background: rgba(255, 130, 40, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 130, 40, 0.2);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-primary {
            background: linear-gradient(135deg, #ff6b35 0%, #f7941d 100%);
            color: #0f0f1a;
            border: none;
        }

        .button-danger {
            background: rgba(244, 67, 54, 0.2);
            color: #ff6b6b;
            border-color: rgba(244, 67, 54, 0.3);
        }

        /* Dark theme selects */
        .example-select, .orchestration-select {
            padding: 0.75rem 1rem;
            border: 1px solid rgba(255, 130, 40, 0.3);
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
        }

        .example-select:hover, .orchestration-select:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: #ff6b35;
        }

        .example-select:focus, .orchestration-select:focus {
            outline: none;
            border-color: #ff6b35;
            box-shadow: 0 0 0 2px rgba(255, 130, 40, 0.2);
        }

        /* New orchestration section styles */
        .orchestration-section {
            background: #f1f3f4;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #e1e5e9;
        }

        .search-container {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .search-input {
            flex: 1;
            padding: 0.6rem 0.8rem;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 0.85rem;
            background: white;
            transition: border-color 0.3s;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .orchestration-dropdown {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .dropdown-actions {
            display: flex;
            gap: 0.5rem;
        }

        .dropdown-actions .button {
            flex: 1;
            font-size: 0.8rem;
            padding: 0.5rem 0.7rem;
        }

        .button-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
        }

        .button-success:hover {
            background: linear-gradient(135deg, #218838, #1ba885);
            transform: translateY(-1px);
        }

        .button-danger {
            background: linear-gradient(135deg, #dc3545, #e74c3c);
            color: white;
            border: none;
        }

        .button-danger:hover {
            background: linear-gradient(135deg, #c82333, #dc2626);
            transform: translateY(-1px);
        }

        .button-danger:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .workflow-info {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            max-height: 400px;
            overflow-y: auto;
        }

        .workflow-info h3 {
            color: #333;
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }

        .workflow-info p {
            color: #666;
            font-size: 0.85rem;
            margin-bottom: 0.25rem;
        }

        .expandable-section {
            margin-top: 1rem;
            border-top: 1px solid #e1e5e9;
            padding-top: 1rem;
        }

        .expandable-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
            background: #e9ecef;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            transition: background 0.3s;
        }

        .expandable-header:hover {
            background: #dee2e6;
        }

        .expandable-header h4 {
            margin: 0;
            font-size: 0.9rem;
            color: #333;
        }

        .expandable-header .toggle-icon {
            transition: transform 0.3s;
        }

        .expandable-header.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        .expandable-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .expandable-content.expanded {
            max-height: 500px;
            overflow-y: auto;
        }

        .node-item, .edge-item {
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 6px;
            padding: 0.5rem;
            margin-bottom: 0.3rem;
        }

        .tool-pill {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.65rem;
            margin: 0.1rem 0.2rem 0.1rem 0;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Enhanced Results Display - Rich Panel Inspired */
        .enhanced-results {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .results-section h4 {
            color: #333;
            margin: 0 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #ff6b35;
            font-size: 1.1rem;
        }

        .task-result-card {
            border: 2px solid #ff6b35;
            border-radius: 8px;
            margin-bottom: 1rem;
            background: #f8feff;
            overflow: hidden;
        }

        .task-header {
            background: linear-gradient(135deg, #ff6b35, #f7941d);
            color: white;
            padding: 0.75rem;
            font-weight: bold;
        }

        .agent-tools-used {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            font-weight: normal;
        }

        .agent-tools-used .tool-pill {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-size: 0.7rem;
        }

        .task-content {
            padding: 1rem;
        }

        .result-text {
            line-height: 1.6;
            color: #333;
        }

        .result-json {
            background: #f1f3f4;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 1rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            color: #333;
            overflow-x: auto;
        }

        .tool-usage-highlight {
            background: #ffeb3b;
            color: #333;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-weight: 500;
        }

        /* Tool Usage Results Panels */
        .tool-usage-panels {
            margin-top: 1rem;
        }

        .tool-usage-panel {
            border: 2px solid #00bcd4;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            background: #e0f7fa;
        }

        .tool-usage-header {
            background: #00bcd4;
            color: white;
            padding: 0.5rem;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .tool-usage-content {
            padding: 0.75rem;
        }

        .tool-args {
            color: #ff9800;
            font-family: monospace;
            font-size: 0.85rem;
            margin: 0.25rem 0;
        }

        .tool-result {
            color: #4caf50;
            font-weight: 500;
            margin: 0.25rem 0;
        }

        .tool-result::before {
            content: "✅ ";
            margin-right: 0.25rem;
        }

        /* Execution Task Enhancement */
        .execution-task {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #fafafa;
        }

        .execution-task.completed {
            border-color: #4caf50;
            background: #e8f5e8;
        }

        .execution-task.running {
            border-color: #ff9800;
            background: #fff8e1;
        }

        .execution-task.failed {
            border-color: #f44336;
            background: #ffebee;
        }

        .node-item h5, .edge-item h5 {
            margin: 0 0 0.5rem 0;
            font-size: 0.85rem;
            color: #333;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .node-item .detail-row, .edge-item .detail-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 0.25rem;
        }

        .node-item .config-box, .edge-item .condition-box {
            background: #f8f9fa;
            border: 1px solid #e1e5e9;
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.5rem;
            font-family: monospace;
            font-size: 0.7rem;
            overflow-x: auto;
        }

        .port-badge {
            display: inline-block;
            background: #e9ecef;
            color: #495057;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            margin-right: 0.25rem;
        }

        .port-badge.input {
            background: #d1ecf1;
            color: #0c5460;
        }

        .port-badge.output {
            background: #d4edda;
            color: #155724;
        }

        .status {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            display: inline-block;
        }

        .status-connected {
            background: #d4edda;
            color: #155724;
        }

        .status-disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .status-loading {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-running {
            background: #cce5ff;
            color: #004085;
        }
        
        .status-completed {
            background: #d4edda;
            color: #155724;
        }
        
        .status-failed {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-started {
            background: #e2e3e5;
            color: #383d41;
        }
        
        .execution-task {
            padding: 0.5rem 0.75rem;
            margin: 0.5rem 0;
            border-radius: 6px;
            font-size: 0.85rem;
            background: rgba(30, 30, 45, 0.9);
            border-left: 4px solid #28a745;
            color: #e0e0e0;
            font-weight: 500;
        }
        
        .execution-task.running {
            border-left-color: #007bff;
            background: rgba(0, 123, 255, 0.15);
            color: #a0d8ff;
        }
        
        .execution-task.completed {
            border-left-color: #28a745;
            background: rgba(40, 167, 69, 0.15);
            color: #90ff90;
        }
        
        .execution-task.failed {
            border-left-color: #dc3545;
            background: rgba(220, 53, 69, 0.15);
            color: #ff9999;
        }

        /* Loading and thinking animations */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        @keyframes thinking-dots {
            0% { content: '...'; }
            33% { content: '.'; }
            66% { content: '..'; }
            100% { content: '...'; }
        }

        @keyframes running-glow {
            0% { box-shadow: 0 0 5px rgba(0, 123, 255, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 123, 255, 0.6); }
            100% { box-shadow: 0 0 5px rgba(0, 123, 255, 0.3); }
        }

        @keyframes running-spinner {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes running-bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-3px); }
            60% { transform: translateY(-1px); }
        }

        .running-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
        }

        .running-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255, 193, 7, 0.3);
            border-top: 2px solid #ffc107;
            border-radius: 50%;
            animation: running-spinner 1s linear infinite;
        }

        .running-dots::after {
            content: "⚡";
            animation: running-bounce 1.4s ease-in-out infinite;
            color: #ffc107;
            margin-left: 0.2rem;
        }

        .runtime-display {
            font-family: 'Courier New', monospace;
            color: #6c757d;
            font-size: 0.85em;
        }

        .execution-task.running {
            animation: running-glow 2s ease-in-out infinite;
        }

        .execution-task.running::after {
            content: " ⚡ processing...";
            animation: pulse 1.5s ease-in-out infinite;
            color: #007bff;
            font-weight: 600;
        }
        
        /* Simple timer display for running executions */
        .execution-runtime {
            font-family: 'Courier New', monospace;
            color: #ffc107;
            font-weight: bold;
        }
        
        /* Tab Content Layout Adjustments */
        .tab-content {
            flex: 1;
            display: none;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        
        .tab-content.active {
            display: flex;
        }
        
        .bottom-panel {
            display: flex;
            flex-direction: column;
        }

        .button.loading {
            animation: pulse 1.5s ease-in-out infinite;
            position: relative;
        }

        .button.loading::after {
            content: "";
            position: absolute;
            width: 16px;
            height: 16px;
            margin: auto;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
        }

        @keyframes spin {
            0% { transform: translateY(-50%) rotate(0deg); }
            100% { transform: translateY(-50%) rotate(360deg); }
        }

        .thinking-indicator {
            display: inline-block;
            animation: thinking-dots 2s ease-in-out infinite;
        }

        .thinking-indicator::after {
            content: "...";
            animation: pulse 1s ease-in-out infinite;
        }

        .flow-container {
            width: 100%;
            height: 100%;
            background: transparent;
        }
        
        /* React Flow Background */
        .react-flow {
            background: transparent !important;
        }
        
        .react-flow__background {
            background: transparent !important;
        }
        
        .react-flow__background pattern {
            stroke: rgba(100, 255, 100, 0.05) !important;
        }

        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            display: flex;
            gap: 0.5rem;
        }

        .control-button {
            padding: 0.5rem;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
        }

        .control-button:hover {
            background: #f8f9fa;
            transform: scale(1.05);
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #ff6b35;
            text-align: center;
            padding: 2rem;
        }

        .empty-state .icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.7;
            animation: pulse 2s infinite;
        }
        
        .empty-state h2 {
            color: #e0e0e0;
            margin-bottom: 0.5rem;
        }
        
        .empty-state p {
            color: #a0a0a0;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 1.5s infinite;
        }
        
        /* Node and Edge Items */
        .node-item, .edge-item {
            background: rgba(255, 130, 40, 0.1);
            border: 1px solid rgba(255, 130, 40, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            transition: all 0.3s ease;
        }
        
        .node-item:hover, .edge-item:hover {
            background: rgba(255, 130, 40, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 130, 40, 0.2);
        }
        
        .port-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            margin: 0 0.2rem;
        }
        
        .port-badge.input {
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }
        
        .port-badge.output {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }
        
        .config-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 0.5rem;
            margin-top: 0.5rem;
            font-family: monospace;
            font-size: 0.8rem;
            white-space: pre-wrap;
            color: #ff6b35;
        }
        
        .condition-box {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 6px;
            padding: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        /* Fix select option colors for dark theme */
        select option {
            background: #1a1a2e;
            color: #e0e0e0;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 130, 40, 0.3);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 130, 40, 0.5);
        }
        
        /* React Flow Node Styling - IO.net Inspired Electric Theme */
        .react-flow__node {
            transition: all 0.1s ease-out;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%) !important;
            border: 2px solid rgba(100, 255, 100, 0.3) !important;
            border-radius: 16px !important;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.6),
                0 4px 16px rgba(138, 43, 226, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 25px rgba(138, 43, 226, 0.15);
        }
        
        .react-flow__node:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.8),
                0 8px 24px rgba(138, 43, 226, 0.25),
                0 4px 16px rgba(100, 255, 100, 0.2),
                0 0 30px rgba(138, 43, 226, 0.12) !important;
            border-color: rgba(100, 255, 100, 0.8) !important;
            background: linear-gradient(135deg, #1e1e35 0%, #1a2545 100%) !important;
        }
        
        .react-flow__node.selected {
            transform: translateY(-2px);
            box-shadow: 
                0 0 0 3px rgba(100, 255, 100, 0.6),
                0 12px 40px rgba(0, 0, 0, 0.7),
                0 6px 20px rgba(138, 43, 226, 0.2),
                0 0 25px rgba(100, 255, 100, 0.15) !important;
            border-color: rgba(100, 255, 100, 1) !important;
            background: linear-gradient(135deg, #22223a 0%, #1e2948 100%) !important;
        }

        /* Specific node type styling */
        .react-flow__node[data-type="tool"] {
            background: linear-gradient(135deg, #1a1a2e 0%, #0f1419 100%) !important;
            border-color: rgba(100, 255, 100, 0.4) !important;
        }

        .react-flow__node[data-type="agent"] {
            background: linear-gradient(135deg, #16213e 0%, #0a1628 100%) !important;
            border-color: rgba(255, 130, 40, 0.4) !important;
        }

        .react-flow__node[data-type="agent"]:hover {
            border-color: rgba(255, 130, 40, 0.8) !important;
            box-shadow: 0 12px 35px rgba(255, 130, 40, 0.3), 0 0 20px rgba(255, 130, 40, 0.2) !important;
        }

        .react-flow__node[data-type="agent"].selected {
            border-color: rgba(255, 130, 40, 1) !important;
            box-shadow: 0 0 0 3px rgba(255, 130, 40, 0.6), 0 8px 25px rgba(255, 130, 40, 0.2) !important;
        }
        
        .react-flow__edge {
            transition: all 0.3s ease;
        }
        
        .react-flow__edge:hover {
            stroke: rgba(100, 255, 100, 1) !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 8px rgba(100, 255, 100, 0.6));
        }
        
        .react-flow__edge.selected {
            stroke: rgba(100, 255, 100, 1) !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 12px rgba(100, 255, 100, 0.8));
        }
        
        /* Node Content Styling */
        .node-content {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 500;
            letter-spacing: -0.01em;
        }
        
        .node-title {
            font-size: 12px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.98);
            margin-bottom: 6px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #ffffff, #e0e0e0);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
        }
        
        .node-id {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 500;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            background: rgba(0, 0, 0, 0.2);
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: inline-block;
        }
        
        .node-instructions {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.85);
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 130, 40, 0.2);
            border-radius: 6px;
            padding: 6px 8px;
            margin: 6px 0;
            line-height: 1.4;
            max-height: 60px;
            overflow-y: auto;
            backdrop-filter: blur(4px);
            transition: all 0.3s ease;
        }

        .node-instructions:hover {
            border-color: rgba(255, 130, 40, 0.4);
            background: rgba(0, 0, 0, 0.4);
            max-height: 120px;
        }

        .node-instructions-collapsed {
            max-height: 20px;
            overflow: hidden;
            cursor: pointer;
        }

        .node-instructions-collapsed::after {
            content: " ▼";
            color: rgba(255, 130, 40, 0.7);
            font-size: 8px;
        }

        .instructions-toggle {
            color: rgba(255, 130, 40, 0.8);
            cursor: pointer;
            font-size: 8px;
            float: right;
            margin-top: -2px;
        }

        .node-instructions-expandable {
            cursor: pointer;
            position: relative;
        }

        .node-instructions-expandable::after {
            content: "👁️";
            position: absolute;
            top: 4px;
            right: 4px;
            font-size: 10px;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .node-instructions-expandable:hover::after {
            opacity: 1;
        }

        .instructions-full {
            animation: fadeIn 0.3s ease;
        }

        .instructions-preview {
            transition: opacity 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Rich Panel-Inspired Tool Usage Display */
        .tool-usage-panels {
            margin-top: 1rem;
        }

        .tool-usage-panel {
            border: 2px solid #00bcd4;
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 188, 212, 0.1);
            background: rgba(0, 188, 212, 0.02);
        }

        .tool-usage-header {
            background: linear-gradient(135deg, #00bcd4, #0097a7);
            color: white;
            padding: 0.75rem 1rem;
            font-weight: 600;
            font-size: 0.9rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .tool-usage-content {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.98);
            color: #333;
        }

        .tool-args {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.75rem;
            margin: 0.5rem 0;
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 0.85rem;
            overflow-x: auto;
            border-left: 4px solid #00bcd4;
        }

        .tool-result {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            border-radius: 6px;
            padding: 0.75rem;
            margin: 0.5rem 0;
            color: #166534;
            font-weight: 500;
            border-left: 4px solid #22c55e;
        }

        .tool-result::before {
            content: "✅ ";
            margin-right: 0.5rem;
        }

        .tool-result pre {
            margin: 0;
            background: transparent;
            border: none;
            padding: 0;
            color: inherit;
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
        }
        
        .tool-pill {
            display: inline-block;
            background: linear-gradient(135deg, rgba(100, 255, 100, 0.15), rgba(100, 255, 100, 0.08));
            border: 1px solid rgba(100, 255, 100, 0.4);
            color: rgba(100, 255, 100, 0.95);
            padding: 3px 8px;
            border-radius: 14px;
            font-size: 8px;
            font-weight: 700;
            margin: 2px 3px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            transition: all 0.3s ease;
            backdrop-filter: blur(6px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .tool-pill:hover {
            background: linear-gradient(135deg, rgba(100, 255, 100, 0.25), rgba(100, 255, 100, 0.15));
            border-color: rgba(100, 255, 100, 0.8);
            color: rgba(100, 255, 100, 1);
            transform: translateY(-1px) scale(1.05);
            box-shadow: 0 4px 12px rgba(100, 255, 100, 0.3);
        }
        
        .port-badge {
            display: inline-block;
            padding: 2px 4px;
            border-radius: 8px;
            font-size: 7px;
            font-weight: 600;
            margin: 1px;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
        }
        
        .port-badge.input {
            background: rgba(255, 152, 0, 0.15);
            border: 1px solid rgba(255, 152, 0, 0.3);
            color: rgba(255, 152, 0, 0.9);
        }
        
        .port-badge.input:hover {
            background: rgba(255, 152, 0, 0.25);
            border-color: rgba(255, 152, 0, 0.6);
            color: rgba(255, 152, 0, 1);
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
        }
        
        .port-badge.output {
            background: rgba(76, 175, 80, 0.15);
            border: 1px solid rgba(76, 175, 80, 0.3);
            color: rgba(76, 175, 80, 0.9);
        }
        
        .port-badge.output:hover {
            background: rgba(76, 175, 80, 0.25);
            border-color: rgba(76, 175, 80, 0.6);
            color: rgba(76, 175, 80, 1);
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        
        /* Tool Search Results */
        .tool-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(20, 20, 35, 0.95);
            border: 1px solid rgba(255, 130, 40, 0.3);
            border-radius: 8px;
            border-top: none;
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .tool-result-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 130, 40, 0.2);
            transition: background 0.2s ease;
        }
        
        .tool-result-item:hover {
            background: rgba(255, 130, 40, 0.1);
        }
        
        .tool-result-item:last-child {
            border-bottom: none;
        }
        
        .tool-result-name {
            font-weight: bold;
            color: #ff6b35;
            margin-bottom: 0.25rem;
        }
        
        .tool-result-desc {
            font-size: 0.8rem;
            color: #a0a0a0;
            line-height: 1.3;
        }

        /* User Input Form Styles */
        .user-input-form {
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid rgba(100, 255, 100, 0.3);
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .user-input-form h3 {
            color: #64FF64;
            margin: 0 0 1rem 0;
            font-size: 1.2rem;
        }

        .user-input-form .form-description {
            color: #b0b0b0;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
        }

        .form-field {
            margin-bottom: 1rem;
        }

        .form-field label {
            display: block;
            color: #e0e0e0;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .form-field label .required {
            color: #ff6b6b;
        }

        .form-field input,
        .form-field textarea,
        .form-field select {
            width: 100%;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(100, 255, 100, 0.3);
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .form-field input:focus,
        .form-field textarea:focus,
        .form-field select:focus {
            outline: none;
            border-color: #64FF64;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 2px rgba(100, 255, 100, 0.2);
        }

        .form-field textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Enhanced Text Input Styles */
        .enhanced-text-input-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px;
            background: rgba(20, 20, 35, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(255, 130, 40, 0.2);
            margin-bottom: 16px;
        }

        .enhanced-input-label {
            color: #ff6b35;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .enhanced-textarea-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .enhanced-textarea {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 2px solid rgba(255, 130, 40, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #e0e0e0;
            font-family: 'Segoe UI', monospace;
            font-size: 14px;
            resize: vertical;
            transition: all 0.3s ease;
            line-height: 1.5;
        }

        .enhanced-textarea:focus {
            outline: none;
            border-color: #ff6b35;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 0 2px rgba(255, 130, 40, 0.2);
        }

        .enhanced-textarea::placeholder {
            color: rgba(224, 224, 224, 0.6);
            font-style: italic;
        }

        .textarea-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 6px;
            font-size: 12px;
            color: rgba(224, 224, 224, 0.6);
        }

        .char-count {
            color: rgba(255, 130, 40, 0.7);
        }

        .enhanced-run-button {
            align-self: flex-end;
            padding: 8px 16px;
            background: linear-gradient(135deg, #ff6b35 0%, #f7941d 100%);
            color: #0f0f1a;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .enhanced-run-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 130, 40, 0.4);
        }

        .enhanced-run-button:active {
            transform: translateY(0);
        }

        .enhanced-run-button .icon {
            width: 14px;
            height: 14px;
        }

        /* Collection Suggestions Styles */
        .suggestions-container {
            margin-bottom: 12px;
            background: rgba(15, 15, 35, 0.9);
            border: 1px solid rgba(255, 130, 40, 0.2);
            border-radius: 8px;
            padding: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .suggestions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 130, 40, 0.1);
        }

        .suggestions-title {
            font-size: 12px;
            font-weight: 500;
            color: #ff6b35;
        }

        .suggestions-source {
            font-size: 10px;
            color: rgba(224, 224, 224, 0.7);
            font-style: italic;
        }

        .suggestions-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .suggestion-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .suggestion-item:hover {
            background: rgba(255, 130, 40, 0.1);
            border-color: rgba(255, 130, 40, 0.3);
        }

        .suggestion-text {
            font-size: 12px;
            color: #e0e0e0;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 8px;
        }

        .suggestion-apply {
            font-size: 10px;
            color: #ff6b35;
            font-weight: 500;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .suggestion-item:hover .suggestion-apply {
            opacity: 1;
        }

        /* Collection Actions Styles */
        .collection-actions {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }
        
        /* Execution Mode Indicators */
        .execution-mode-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            backdrop-filter: blur(8px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 10;
            cursor: help;
            transition: all 0.3s ease;
        }
        
        .execution-mode-indicator.for-each {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.9), rgba(255, 152, 0, 0.8));
            color: #fff;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.4);
        }
        
        .execution-mode-indicator.consolidate {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.9), rgba(56, 142, 60, 0.8));
            color: #fff;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
        }
        
        .execution-mode-indicator:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }
        
        /* Enhanced Node Shapes CSS */
        .react-flow__node[data-type="tool"] {
            background: linear-gradient(135deg, #1a1a2e 0%, #0f1419 100%) !important;
            border-color: rgba(100, 255, 100, 0.4) !important;
            clip-path: polygon(20% 0%, 80% 0%, 100% 50%, 80% 100%, 20% 100%, 0% 50%);
        }
        
        .react-flow__node[data-type="agent"] {
            background: linear-gradient(135deg, #16213e 0%, #0a1628 100%) !important;
            border-color: rgba(255, 130, 40, 0.4) !important;
            border-radius: 50% !important;
        }
        
        .react-flow__node[data-type="decision"],
        .react-flow__node[data-type="agent"][data-has-routing-tools="true"] {
            background: linear-gradient(135deg, rgba(255, 140, 0, 0.3), rgba(255, 165, 0, 0.2)) !important;
            border-color: rgba(255, 165, 0, 0.8) !important;
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            min-width: 280px !important;
            min-height: 120px !important;
        }
        
        .react-flow__node[data-type="workflow_call"] {
            background: linear-gradient(135deg, rgba(148, 0, 211, 0.15), rgba(138, 43, 226, 0.12)) !important;
            border-color: rgba(148, 0, 211, 0.4) !important;
        }
        
        /* Override React Flow default node styling to apply our custom shapes */
        .react-flow__node-default {
            background: transparent !important;
            border: none !important;
            padding: 0 !important;
        }
        
        /* Node content container should handle all styling */
        .react-flow__node-default .node-content {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        /* Conditional Gate Visualization */
        .conditional-gate-indicator {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 15px;
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.8), rgba(255, 152, 0, 0.6));
            border-radius: 15px 15px 0 0;
            border: 2px solid rgba(255, 193, 7, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            z-index: 20;
        }
        
        .conditional-gate-indicator::after {
            content: "⚡";
            animation: pulse 2s ease-in-out infinite;
        }
        
        /* Simple Running Timer Animation */
        .running-timer {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .running-timer::before {
            content: "⏱️";
            animation: pulse 1s ease-in-out infinite;
        }
        
        .timer-seconds {
            color: #ffc107;
            min-width: 4ch;
            text-align: right;
        }
        
        /* Edge routing path indicators */
        .react-flow__edge[data-routing="true"] {
            stroke: #ffc107 !important;
            stroke-width: 3px !important;
            stroke-dasharray: 8,4;
            animation: routing-flow 2s linear infinite;
        }
        
        @keyframes routing-flow {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: 24; }
        }
        
        /* Skipped path visualization */
        .react-flow__edge[data-skipped="true"] {
            stroke: rgba(100, 100, 100, 0.3) !important;
            stroke-width: 2px !important;
            stroke-dasharray: 4,8;
            opacity: 0.5;
        }

        .collection-action-btn {
            background: rgba(255, 130, 40, 0.1);
            border: 1px solid rgba(255, 130, 40, 0.3);
            border-radius: 4px;
            padding: 4px 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
            color: #ff6b35;
        }

        .collection-action-btn:hover {
            background: rgba(255, 130, 40, 0.2);
            border-color: rgba(255, 130, 40, 0.5);
            transform: translateY(-1px);
        }

        .collection-action-btn:active {
            transform: translateY(0);
        }

        .form-field .field-description {
            color: #a0a0a0;
            font-size: 0.8rem;
            margin-top: 0.25rem;
        }

        .form-field.checkbox {
            display: flex;
            align-items: center;
        }

        .form-field.checkbox input {
            width: auto;
            margin-right: 0.5rem;
        }

        .form-field.checkbox label {
            margin-bottom: 0;
        }

        .form-submit-container {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .form-submit-btn {
            background: linear-gradient(135deg, #64FF64, #4CAF50);
            color: #000;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95rem;
        }

        .form-submit-btn:hover {
            background: linear-gradient(135deg, #4CAF50, #64FF64);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(100, 255, 100, 0.3);
        }

        .form-submit-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .form-validation-error {
            color: #ff6b6b;
            font-size: 0.8rem;
            margin-top: 0.25rem;
        }
        
        /* System Message Styling */
        .message.system .message-bubble {
            background: linear-gradient(135deg, rgba(100, 255, 100, 0.1), rgba(100, 255, 100, 0.05));
            border: 1px solid rgba(100, 255, 100, 0.3);
            color: rgba(100, 255, 100, 0.9);
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 0.85em;
            white-space: pre-wrap;
        }
        
        .message.system .message-bubble strong {
            color: rgba(100, 255, 100, 1);
        }
        
        /* Collapsible Message Styling */
        .collapsible-message {
            position: relative;
        }
        
        .message-preview,
        .message-full {
            transition: all 0.3s ease;
        }
        
        .message-preview {
            cursor: pointer;
            position: relative;
        }
        
        .message-preview:hover {
            background: rgba(100, 255, 100, 0.05);
            border-radius: 8px;
            padding: 4px;
            margin: -4px;
        }
        
        .collapsible-message hr {
            margin: 0.5rem 0;
        }
        
        /* Enhanced UI Elements for Results */
        #workflowInfo {
            background: linear-gradient(135deg, rgba(100, 255, 100, 0.05), rgba(255, 130, 40, 0.08));
            border: 1px solid rgba(100, 255, 100, 0.3);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }
        
        #workflowInfo::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                transparent 30%, 
                rgba(255, 130, 40, 0.3) 50%, 
                transparent 70%);
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s ease;
        }
        
        #workflowInfo:hover::after {
            opacity: 1;
            animation: shimmer 2s linear infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #workflowTitle {
            color: #64FF64 !important;
            text-shadow: 0 0 10px rgba(100, 255, 100, 0.5);
            font-weight: 700;
        }
        
        #executionStatusSection {
            background: linear-gradient(135deg, 
                rgba(0, 123, 255, 0.05) 0%, 
                rgba(0, 123, 255, 0.08) 100%);
            border: 1px solid rgba(0, 123, 255, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            position: relative;
            backdrop-filter: blur(10px);
        }
        
        #executionResults {
            background: linear-gradient(135deg, 
                rgba(40, 167, 69, 0.05) 0%, 
                rgba(40, 167, 69, 0.08) 100%);
            border: 1px solid rgba(40, 167, 69, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            position: relative;
            backdrop-filter: blur(10px);
        }
        
        #executionStatusSection h4 {
            color: #007bff !important;
            text-shadow: 0 0 8px rgba(0, 123, 255, 0.6);
        }
        
        #executionResults h4 {
            color: #28a745 !important;
            text-shadow: 0 0 8px rgba(40, 167, 69, 0.6);
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(100, 255, 100, 0.1);
            color: rgba(224, 224, 224, 0.9);
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-row span:first-child {
            color: rgba(255, 130, 40, 0.9);
            font-weight: 600;
        }
        
        /* Glowing accents */
        .status.status-running {
            background: linear-gradient(135deg, #007bff, #00bcd4);
            color: white;
            text-shadow: 0 0 10px rgba(0, 123, 255, 0.8);
            animation: pulse-glow 2s ease-in-out infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); }
            50% { box-shadow: 0 0 20px rgba(0, 123, 255, 0.8), 0 0 30px rgba(255, 130, 40, 0.6); }
        }
        
        .execution-task {
            background: linear-gradient(135deg, 
                rgba(30, 30, 45, 0.5) 0%, 
                rgba(20, 20, 35, 0.5) 100%);
            border-left: 3px solid #64FF64;
            margin: 0.5rem 0;
            padding: 0.75rem;
            border-radius: 8px;
            position: relative;
            transition: all 0.3s ease;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }
        
        .execution-task:hover {
            transform: translateX(5px);
            box-shadow: -5px 0 20px rgba(100, 255, 100, 0.3);
        }
        
        /* Form styling updates */
        .form-submit-btn {
            background: linear-gradient(135deg, #64FF64, #4CAF50);
            color: #000;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(100, 255, 100, 0.4);
        }
        
        .form-submit-btn:hover {
            background: linear-gradient(135deg, #4CAF50, #64FF64);
            box-shadow: 0 6px 25px rgba(100, 255, 100, 0.6);
        }
        
        /* Tab Panel Styling */
        .tab-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .tab-header {
            display: flex;
            gap: 0;
            border-bottom: 2px solid rgba(100, 255, 100, 0.2);
            margin-bottom: 1rem;
            background: rgba(20, 20, 35, 0.5);
            border-radius: 8px 8px 0 0;
            overflow: hidden;
        }
        
        .tab-button {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: rgba(255, 130, 40, 0.7);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            border-radius: 8px 8px 0 0;
        }
        
        .tab-button:hover {
            background: rgba(100, 255, 100, 0.1);
            color: rgba(100, 255, 100, 0.9);
        }
        
        .tab-button.active {
            background: rgba(100, 255, 100, 0.15);
            color: #64FF64;
            text-shadow: 0 0 10px rgba(100, 255, 100, 0.5);
        }
        
        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #64FF64, transparent);
            animation: shimmer 2s linear infinite;
        }
        
        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
            animation: fadeIn 0.3s ease;
        }
        
        .tab-content.active {
            display: flex;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Execution Logs Styling - Compact Nerd Mode */
        .execution-logs {
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 0.75rem;
            line-height: 1.2;
            color: rgba(200, 200, 200, 0.9);
            white-space: pre-wrap;
            word-break: break-word;
            background: rgba(0, 0, 0, 0.8);
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid rgba(100, 255, 100, 0.1);
            overflow-x: auto;
            overflow-y: auto;
            height: 100%;
        }
        
        .log-line {
            margin: 0;
            padding: 2px 0;
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
        }
        
        .log-timestamp {
            color: #666;
        }
        
        .log-node-id {
            color: #ff6b35;
            font-weight: bold;
        }
        
        .log-success {
            color: #90ff90;
        }
        
        .log-error {
            color: #ff6666;
        }
        
        .log-warning {
            color: #ffaa00;
        }
        
        .log-tools {
            color: #64FF64;
            font-weight: bold;
        }
        
        .log-tool {
            color: #FFD700;
            font-weight: bold;
        }
        
        .log-result {
            color: #87CEEB;
            font-style: italic;
        }
        
        .log-dim {
            color: #666;
        }
        
        .log-highlight {
            color: #ffff00;
            font-weight: bold;
        }
        
        .log-metric {
            color: #00ffff;
        }
        
        /* Compact Cockpit Results Styling */
        .node-result-modal {
            background: linear-gradient(135deg, rgba(20, 20, 35, 0.6), rgba(10, 10, 25, 0.8));
            border: 1px solid rgba(100, 255, 100, 0.3);
            border-radius: 6px;
            padding: 0.5rem;
            margin: 0.25rem 0;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .node-result-modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, #64FF64, transparent);
            animation: shimmer 3s linear infinite;
        }
        
        .node-result-header {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            margin-bottom: 0.3rem;
            padding-bottom: 0.3rem;
            border-bottom: 1px solid rgba(100, 255, 100, 0.15);
            font-size: 0.85rem;
        }
        
        .node-result-icon {
            font-size: 1.5rem;
            filter: drop-shadow(0 0 10px currentColor);
        }
        
        .node-result-title {
            flex: 1;
            font-size: 1.1rem;
            font-weight: 600;
            color: #ff6b35;
            text-shadow: 0 0 10px rgba(255, 130, 40, 0.5);
        }
        
        .node-result-type {
            font-size: 0.8rem;
            color: rgba(100, 255, 100, 0.7);
            padding: 0.2rem 0.6rem;
            background: rgba(100, 255, 100, 0.1);
            border-radius: 12px;
            border: 1px solid rgba(100, 255, 100, 0.3);
        }
        
        .node-result-metrics {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .metric-card {
            background: rgba(30, 30, 45, 0.6);
            border: 1px solid rgba(100, 255, 100, 0.2);
            border-radius: 4px;
            padding: 0.3rem 0.5rem;
            text-align: center;
            transition: all 0.3s ease;
            flex: 1;
        }
        
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(100, 255, 100, 0.2);
            border-color: rgba(100, 255, 100, 0.4);
        }
        
        .metric-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: #00ffff;
            font-family: 'Fira Code', monospace;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .metric-label {
            font-size: 0.75rem;
            color: rgba(200, 200, 200, 0.7);
            margin-top: 0.2rem;
        }
        
        .compact-metrics-pill {
            display: inline-block;
            background: rgba(30, 30, 45, 0.8);
            border: 1px solid rgba(100, 255, 100, 0.3);
            border-radius: 12px;
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            color: #00ffff;
            font-family: 'Fira Code', monospace;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
        }
        
        .node-result-content {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(100, 255, 100, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            font-family: 'Fira Code', monospace;
            font-size: 0.85rem;
            color: rgba(200, 200, 200, 0.9);
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .tool-usage-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }
        
        .tool-pill {
            background: linear-gradient(135deg, rgba(100, 255, 100, 0.2), rgba(255, 130, 40, 0.2));
            border: 1px solid rgba(100, 255, 100, 0.4);
            color: #90ff90;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 9px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 2px;
            transition: all 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }
        
        .tool-pill:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(100, 255, 100, 0.3);
            background: linear-gradient(135deg, rgba(100, 255, 100, 0.3), rgba(255, 130, 40, 0.3));
        }
        
        /* Routing Tool Pills */
        .tool-pill.routing-tool {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.3), rgba(255, 140, 0, 0.2));
            border: 1px solid rgba(255, 165, 0, 0.5);
            color: #ffa500;
            font-weight: bold;
        }
        
        /* SLA Badge Display */
        .sla-badge {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 8px;
        }
        
        .sla-badge.decision {
            background: rgba(255, 165, 0, 0.2);
            border: 1px solid rgba(255, 165, 0, 0.5);
            color: #ffa500;
        }
        
        .sla-badge.strict {
            background: rgba(255, 69, 0, 0.2);
            border: 1px solid rgba(255, 69, 0, 0.5);
            color: #ff4500;
        }
        
        .sla-badge.basic {
            background: rgba(100, 255, 100, 0.2);
            border: 1px solid rgba(100, 255, 100, 0.5);
            color: #64ff64;
        }

        /* CYBERPUNK TOOL PILLS - IO.NET STYLE */
        .tools-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 12px 0;
        }
        
        .tool-pill-expanded {
            background: linear-gradient(135deg, 
                rgba(255, 165, 0, 0.08) 0%,
                rgba(255, 140, 0, 0.05) 50%,
                rgba(0, 0, 0, 0.4) 100%);
            border: 1px solid rgba(255, 165, 0, 0.3);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(8px);
            position: relative;
            box-shadow: 0 0 8px rgba(255, 165, 0, 0.1);
        }
        
        .tool-pill-expanded:hover {
            border-color: rgba(255, 165, 0, 0.6);
            box-shadow: 
                0 0 20px rgba(255, 165, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }
        
        .tool-pill-expanded.success {
            border-color: rgba(0, 255, 100, 0.3);
        }
        
        .tool-pill-expanded.success:hover {
            border-color: rgba(0, 255, 100, 0.6);
            box-shadow: 
                0 0 20px rgba(0, 255, 100, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .tool-pill-expanded.error {
            border-color: rgba(255, 50, 50, 0.3);
        }
        
        .tool-pill-expanded.error:hover {
            border-color: rgba(255, 50, 50, 0.6);
            box-shadow: 
                0 0 20px rgba(255, 50, 50, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .tool-pill-header {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 165, 0, 0.15);
        }
        
        .tool-status {
            margin-right: 10px;
            font-size: 16px;
        }
        
        .tool-name {
            flex: 1;
            font-weight: 600;
            color: #ffa500;
            font-family: 'Monaco', 'Menlo', monospace;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
        }
        
        .tool-expand {
            color: rgba(255, 165, 0, 0.7);
            font-size: 12px;
            transition: transform 0.2s ease;
        }
        
        .tool-pill-expanded.expanded .tool-expand {
            transform: rotate(180deg);
        }
        
        .tool-details {
            display: none;
            padding: 16px;
            background: rgba(0, 0, 0, 0.4);
        }
        
        .tool-section {
            margin-bottom: 16px;
        }
        
        .tool-section:last-child {
            margin-bottom: 0;
        }
        
        .tool-label {
            color: rgba(0, 255, 255, 0.8);
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            opacity: 0.9;
        }
        
        .tool-data {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.1);
            border-radius: 6px;
            padding: 12px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 11px;
            color: #e0e0e0;
            line-height: 1.4;
            overflow-x: auto;
            white-space: pre;
            margin: 0;
            word-wrap: break-word;
        }
        
        .tool-data:hover {
            border-color: rgba(0, 255, 255, 0.3);
        }

        /* FIXED LAYOUT - STICKY EXEC STATUS + SCROLLABLE RESULTS */
        .execution-status-sticky {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(0, 20, 40, 0.95);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(255, 130, 40, 0.2);
            padding: 12px 16px;
            margin-bottom: 12px;
        }

        .results-scroll-area {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 0 8px;
            min-height: 0; /* Ensure flex child can shrink */
            max-height: calc(100vh - 200px); /* Constrain to viewport height minus space for other elements */
            background: rgba(20, 20, 35, 0.95);
            border-radius: 12px;
            border: 1px solid rgba(100, 255, 100, 0.1);
        }

        .results-content-flat {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-bottom: 16px; /* Small buffer for clean edge */
            padding-top: 8px;
        }

        /* Remove the nested container bullshit */
        .tab-content.active {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* COMPACT DATA INSIGHTS PILL */
        .data-insights-pill {
            display: inline-flex;
            align-items: center;
            background: rgba(0, 255, 255, 0.08);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 12px;
            padding: 2px 8px;
            margin-left: 8px;
            font-size: 10px;
            color: rgba(0, 255, 255, 0.7);
            font-family: 'Monaco', 'Menlo', monospace;
            font-weight: 500;
        }

        /* SLA Status Display */
        .sla-status {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 10px;
            border: 1px solid;
        }
        
        .sla-status.decision {
            background: rgba(255, 165, 0, 0.2);
            color: #ffa500;
            border-color: rgba(255, 165, 0, 0.4);
        }
        
        .sla-status.enforced {
            background: rgba(255, 200, 0, 0.2);
            color: #ffc800;
            border-color: rgba(255, 200, 0, 0.4);
        }
        
        .sla-status.strict {
            background: rgba(255, 50, 50, 0.3);
            color: #ff3232;
            border-color: rgba(255, 50, 50, 0.5);
        }
        
        .sla-icon {
            font-size: 10px;
        }
        
        .sla-label {
            font-weight: bold;
            font-size: 9px;
        }
        
        .sla-detail {
            font-size: 8px;
            opacity: 0.8;
            margin-left: 2px;
        }
        
        /* Enhanced SLA Pills */
        .sla-indicators {
            animation: fadeInUp 0.3s ease-out;
        }
        
        .sla-pill {
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
            user-select: none;
        }
        
        .sla-pill:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            filter: brightness(1.1);
        }
        
        .sla-pill.main-sla {
            border-width: 1.5px;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        .sla-pill.tool-required {
            border-style: dashed;
        }
        
        .sla-pill.final-tool {
            border-style: double;
            border-width: 2px;
        }
        
        .sla-pill.min-calls,
        .sla-pill.timeout {
            opacity: 0.9;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(4px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .data-visualization {
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid rgba(100, 255, 100, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 130, 40, 0.5);
            font-style: italic;
        }
        
        /* Cockpit-style Unified Interface */
        .cockpit-header {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(100, 255, 100, 0.2);
            border-radius: 8px 8px 0 0;
            padding: 0.5rem 1rem;
            margin-bottom: 0;
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 0.75rem;
            color: rgba(200, 200, 200, 0.9);
        }
        
        .execution-header-compact {
            line-height: 1.2;
            white-space: pre-wrap;
        }
        
        .execution-details {
            background: rgba(20, 20, 35, 0.8);
            border: 1px solid rgba(100, 255, 100, 0.2);
            border-top: none;
            border-radius: 0 0 8px 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .cockpit-status-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(100, 255, 100, 0.1);
            margin-bottom: 0.5rem;
        }
        
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.8rem;
        }
        
        .status-indicator.completed {
            color: #90ff90;
        }
        
        .status-indicator.running {
            color: #a0d8ff;
        }
        
        .status-indicator.failed {
            color: #ff6666;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Chat Panel -->
        <div class="chat-panel">
            <div class="chat-header">
                🌊 WorkflowPlanner AI
                <div id="connectionStatus" class="status status-disconnected" style="float: right; font-size: 0.8rem;">Disconnected</div>
            </div>
            
            <!-- Session Controls -->
            <div class="session-controls">
                <div class="session-info">
                    <span id="sessionStatus">💬 <strong>Chat Mode</strong> <span style="color: #64ff64; font-size: 0.9em;">(Memory: ON)</span></span>
                    <div id="conversationInfo" style="font-size: 0.8rem; color: #888; margin-top: 0.25rem;">
                        Loading conversation info...
                    </div>
                </div>
                <div class="session-buttons">
                    <button id="conversationManagerBtn" class="session-btn" title="Manage conversations">
                        📋 Conversations
                    </button>
                    <button id="chatModeToggle" class="session-btn active" title="Toggle between chat mode (persistent conversation) and single-serve mode">
                        🔄 Disable Memory
                    </button>
                    <button id="resetSession" class="session-btn secondary" title="Start a new conversation session">
                        🔄 New Session
                    </button>
                </div>
            </div>
            
            <!-- Conversation Manager Modal -->
            <div id="conversationModal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                    <div class="modal-header">
                        <h3>📋 Conversation Manager</h3>
                        <button id="closeConversationModal" class="close-btn">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                            <button id="newConversationBtn" class="button button-primary">
                                ✨ New Conversation
                            </button>
                            <button id="refreshConversationsBtn" class="button">
                                🔄 Refresh
                            </button>
                        </div>
                        
                        <div id="conversationsList">
                            Loading conversations...
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="chat-messages" id="chatMessages">
                <!-- Messages will be added here -->
                <div class="message assistant">
                    <div class="message-bubble">
                        👋 Hello! I'm your IO.net AI workflow design assistant. Tell me what kind of workflow you'd like to create and I'll help you build it!
                    </div>
                    <div class="message-time">Just now</div>
                </div>
            </div>
            
            <div class="chat-input-container">
                <textarea class="chat-input" id="chatInput" placeholder="Describe your workflow..." rows="3"></textarea>
                <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                    <button class="button button-primary" id="sendBtn" style="flex: 1;">
                        <span>✨ Send</span>
                    </button>
                    <button class="button" id="clearChatBtn">
                        <span>🗑️ Clear</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="flow-area" id="flowArea">
                <!-- Workflow Controls -->
                <div class="workflow-controls" style="display: flex; gap: 1rem; padding: 1rem; background: rgba(10, 10, 10, 0.95); border-bottom: 1px solid rgba(100, 255, 100, 0.2); align-items: center; justify-content: flex-start;">
                    
                    <div class="search-container" style="position: relative; width: 600px;">
                        <!-- Search Tabs -->
                        <div class="search-tabs" style="display: flex; margin-bottom: 0.5rem; background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 0.25rem; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <button class="search-tab active" onclick="switchSearchTab('tools')" id="toolsTab" 
                                    style="flex: 1; padding: 0.6rem 1rem; background: linear-gradient(135deg, rgba(255, 107, 53, 0.3), rgba(255, 107, 53, 0.1)); border: none; border-radius: 8px; color: #ff6b35; cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(255, 107, 53, 0.2);">
                                🔧 Tools
                            </button>
                            <button class="search-tab" onclick="switchSearchTab('workflows')" id="workflowsTab"
                                    style="flex: 1; padding: 0.6rem 1rem; background: transparent; border: none; border-radius: 8px; color: rgba(100, 255, 100, 0.7); cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: all 0.2s ease; margin-left: 0.25rem;">
                                🌊 Workflows
                            </button>
                            <button class="search-tab" onclick="switchSearchTab('analytics')" id="analyticsTab"
                                    style="flex: 1; padding: 0.6rem 1rem; background: transparent; border: none; border-radius: 8px; color: rgba(100, 255, 100, 0.7); cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: all 0.2s ease; margin-left: 0.25rem;">
                                📈 Analytics
                            </button>
                        </div>
                        
                        <!-- Search Input -->
                        <input type="text" class="search-input" id="unifiedSearchInput" placeholder="🔍 Search tools..." style="width: 100%; padding: 0.75rem; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 130, 40, 0.3); border-radius: 10px; color: #e0e0e0; font-size: 0.95rem;">
                        
                        <!-- Search Results -->
                        <div class="search-results" id="searchResults" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: rgba(20, 20, 35, 0.98); border: 1px solid rgba(255, 130, 40, 0.3); border-radius: 10px; margin-top: 0.5rem; max-height: 400px; overflow-y: auto; z-index: 1000;"></div>
                    </div>
                    
                    <div style="flex: 1;"></div>
                    
                    <button class="button" id="executeBtn" disabled>Run</button>
                    <button class="button" id="runWithInputsBtn" disabled style="display: none;">📝 Run with Inputs</button>
                    <button class="button" id="stopBtn" disabled style="display: none;">⏹️</button>
                    <button class="button" id="saveBtn" disabled>💾</button>
                    <button class="button" id="exportBtn" disabled>📤</button>
                    <button class="button button-danger" id="clearBtn" disabled>🗑️</button>
                </div>
                
                <div id="emptyState" class="empty-state">
                    <div class="icon">🌊</div>
                    <h2>Start a conversation</h2>
                    <p>Tell me what workflow you want to create in the chat!</p>
                </div>
                
                <div id="flowContainer" class="flow-container" style="display: none;"></div>
            </div>
            
            <!-- Panel Resizer -->
            <div class="panel-resizer" id="panelResizer" style="display: none;"></div>
            
            <!-- Enhanced Bottom Panel - Results and Status -->
            <div id="bottomPanel" class="bottom-panel" style="display: none;">
                <!-- Tab Container -->
                <div class="tab-container">
                    <!-- Tab Header -->
                    <div class="tab-header">
                        <button class="tab-button active" onclick="switchTab('results')">
                            🎯 Results
                        </button>
                        <button class="tab-button" onclick="switchTab('logs')">
                            📋 Execution Logs
                        </button>
                        <button class="tab-button" onclick="switchTab('prompts')">
                            🤖 Prompts
                        </button>
                    </div>
                    
                    <!-- Results Tab Content - FIXED LAYOUT -->
                    <div id="resultsTab" class="tab-content active">
                        <!-- Sticky Execution Status at Top -->
                        <div id="executionStatusSticky" class="execution-status-sticky">
                            <div id="executionHeaderInfo" class="execution-header-compact"></div>
                        </div>
                        
                        <!-- User Input Form Section -->
                        <div id="userInputSection" style="display: none;">
                            <div id="userInputForm"></div>
                        </div>
                        
                        <!-- Single Scrollable Results Area -->
                        <div id="resultsScrollArea" class="results-scroll-area">
                            <div id="resultsContent" class="results-content-flat"></div>
                        </div>
                    </div>
                    
                    <!-- Logs Tab Content -->
                    <div id="logsTab" class="tab-content">
                        <div class="bottom-section">
                            <div class="execution-logs" id="executionLogs">
                                <div style="text-align: center; color: rgba(255, 130, 40, 0.5); padding: 2rem;">
                                    No execution logs available yet. Run a workflow to see detailed logs.
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Prompts Tab -->
                    <div id="promptsTab" class="tab-content">
                        <div class="bottom-section">
                            <div class="prompts-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding: 0 1rem;">
                                <h3 style="color: #ff6b35; margin: 0;">🤖 Prompt History</h3>
                                <button class="button button-danger" onclick="clearPrompts()" style="font-size: 0.8rem; padding: 0.4rem 0.8rem;">
                                    Clear History
                                </button>
                            </div>
                            <div class="prompts-container" id="promptsContainer" style="max-height: 400px; overflow-y: auto; padding: 0 1rem;">
                                <div style="text-align: center; color: rgba(255, 130, 40, 0.5); padding: 2rem;">
                                    No prompts logged yet. Generate a workflow to see prompt history.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- React and React Flow -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/reactflow@11.10.4/dist/umd/index.js"></script>

    <script>
        // Configuration Constants
        const API_CONFIG = {
            SEARCH_SERVICE_URL: window.location.origin,  // Use same server now that services are integrated
            WEB_SERVICE_URL: window.location.origin,
            SEARCH_DEBOUNCE_MS: 300,
            SEARCH_MAX_RESULTS: 8
        };
        
        // Global state
        let currentWorkflow = null;
        let reactFlowInstance = null;
        let ws = null;
        let currentExecution = null;
        let executionTasks = {};
        let availableTools = {};
        let executionLogs = null; // Store full execution report
        let runtimeUpdateInterval = null; // Timer for runtime updates

        // Initialize WebSocket connection
        function initWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            console.log('🔌 Connecting to WebSocket:', wsUrl);
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('✅ WebSocket connected');
                updateConnectionStatus('connected');
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('📩 WebSocket message:', data.type, data);
                if (data.type === 'workflow_update') {
                    handleWorkflowUpdate(data.workflow);
                } else if (data.type === 'execution_update') {
                    handleExecutionUpdate(data);
                } else if (data.type === 'chat_message') {
                    // Handle chat messages sent via WebSocket (like execution feedback)
                    console.log('💬 Received chat message via WebSocket');
                    addMessageToChat(data.content, data.role, data.metadata);
                }
            };
            
            ws.onclose = function() {
                console.log('❌ WebSocket closed');
                updateConnectionStatus('disconnected');
                // Reconnect after 3 seconds
                setTimeout(initWebSocket, 3000);
            };
            
            ws.onerror = function(error) {
                console.error('❌ WebSocket error:', error);
                updateConnectionStatus('disconnected');
            };
        }

        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = `status status-${status}`;
            statusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }

        // API calls
        async function apiCall(endpoint, options = {}) {
            try {
                console.log(`Making API call to: /api${endpoint}`, options);
                const response = await fetch(`/api${endpoint}`, {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API call failed with status ${response.status}:`, errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log(`API response from /api${endpoint}:`, data);
                return data;
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }

        // Load available tools
        async function loadTools() {
            try {
                const data = await apiCall('/tools');
                const toolsList = document.getElementById('toolsList');
                
                if (data.tools && Object.keys(data.tools).length > 0) {
                    const toolsHtml = Object.entries(data.tools)
                        .slice(0, 10) // Show first 10 tools
                        .map(([name, tool]) => `
                            <div style="margin-bottom: 0.5rem; padding: 0.25rem; background: #f8f9fa; border-radius: 4px;">
                                <strong>${name}</strong><br>
                                <small>${tool.description}</small>
                            </div>
                        `).join('');
                    
                    const remaining = Object.keys(data.tools).length - 10;
                    const suffix = remaining > 0 ? `<div style="text-align: center; color: #666; margin-top: 0.5rem;">...and ${remaining} more tools</div>` : '';
                    
                    toolsList.innerHTML = toolsHtml + suffix;
                    availableTools = data.tools;
                } else {
                    availableTools = {};
                }
            } catch (error) {
                console.error('Failed to load tools:', error);
                availableTools = {};
            }
        }

        // Workflow operations
        async function generateWorkflow() {
            const query = document.getElementById('queryInput').value.trim();
            if (!query) return;

            setLoading(true);
            try {
                const data = await apiCall('/generate', {
                    method: 'POST',
                    body: JSON.stringify({ query, refine: false })
                });
                
                if (data.success) {
                    handleWorkflowUpdate(data.workflow);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Failed to generate workflow: ' + error.message);
            } finally {
                setLoading(false);
            }
        }

        async function refineWorkflow() {
            const query = document.getElementById('queryInput').value.trim();
            if (!query || !currentWorkflow) return;

            setLoading(true);
            try {
                const data = await apiCall('/generate', {
                    method: 'POST',
                    body: JSON.stringify({ query, refine: true })
                });
                
                if (data.success) {
                    handleWorkflowUpdate(data.workflow);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Failed to refine workflow: ' + error.message);
            } finally {
                setLoading(false);
            }
        }


        async function clearWorkflow() {
            try {
                await apiCall('/clear', { method: 'POST' });
                handleWorkflowUpdate(null);
                clearExecutionStatus();
                // Clear execution results
                const resultsScrollArea = document.getElementById('resultsScrollArea');
                const resultsContent = document.getElementById('resultsContent');
                if (resultsScrollArea) {
                    resultsScrollArea.style.display = 'none';
                }
                if (resultsContent) {
                    resultsContent.innerHTML = '';
                }
                // Clear cached user inputs only if explicitly clearing workflow
                clearCachedInputs();
            } catch (error) {
                alert('Failed to clear workflow: ' + error.message);
            }
        }
        
        async function executeWorkflow() {
            if (!currentWorkflow) return;
            
            setExecutionLoading(true);
            try {
                // Always include cached user inputs with execution
                const executionData = { 
                    execute_current: true,
                    // Include workflow data if we loaded from search (server might not have it)
                    workflow_data: currentWorkflow
                };
                
                // Add cached user inputs if any exist
                if (Object.keys(cachedUserInputs).length > 0) {
                    executionData.user_inputs = cachedUserInputs;
                    console.log('🚀 Executing workflow with cached user inputs:', cachedUserInputs);
                    console.log('🔍 DEBUG: executionData being sent:', JSON.stringify(executionData, null, 2));
                } else {
                    console.log('🚀 Executing workflow without user inputs');
                    console.log('🔍 DEBUG: cachedUserInputs is empty or undefined:', cachedUserInputs);
                }
                
                const data = await apiCall('/execute', {
                    method: 'POST',
                    body: JSON.stringify(executionData)
                });
                
                if (data.success) {
                    currentExecution = {
                        id: data.execution_id,
                        status: data.status,
                        workflow_title: currentWorkflow.title,
                        start_time: new Date().toISOString()
                    };
                    showExecutionStatus();
                    updateExecutionInfo();
                    
                    // Start runtime updates for running executions
                    if (data.status === 'running') {
                        startRuntimeUpdates();
                    }
                } else {
                    alert('Failed to start execution: ' + data.error);
                }
            } catch (error) {
                alert('Failed to execute workflow: ' + error.message);
            } finally {
                setExecutionLoading(false);
            }
        }
        
        async function stopExecution() {
            if (!currentExecution) return;
            
            try {
                await apiCall(`/executions/${currentExecution.id}`, { method: 'DELETE' });
                clearExecutionStatus();
            } catch (error) {
                alert('Failed to stop execution: ' + error.message);
            }
        }

        function setLoading(loading) {
            const sendBtn = document.getElementById('sendBtn');
            
            if (sendBtn) {
                sendBtn.disabled = loading;
                if (loading) {
                    sendBtn.innerHTML = '<span>⏳ Generating...</span>';
                    sendBtn.classList.add('loading');
                } else {
                    sendBtn.innerHTML = '<span>✨ Send</span>';
                    sendBtn.classList.remove('loading');
                }
            }
            
            // Note: Removed exampleSelect dropdown handling as UI now uses search
        }

        // Handle workflow updates
        function handleWorkflowUpdate(workflow) {
            console.log('🔄 handleWorkflowUpdate called with:', workflow);
            
            // Store previous workflow before updating
            const previousWorkflow = currentWorkflow;
            currentWorkflow = workflow;
            
            if (workflow) {
                console.log('✅ Workflow received:', {
                    title: workflow.title,
                    nodes: workflow.nodes?.length || 0,
                    edges: workflow.edges?.length || 0,
                    id: workflow.id
                });
                
                // Clear execution state and results when loading a different workflow
                if (previousWorkflow && previousWorkflow.id !== workflow.id) {
                    console.log('🔄 Loading different workflow - clearing execution state');
                    
                    // Clear execution status
                    clearExecutionStatus();
                    
                    // Clear execution results
                    const resultsContent = document.getElementById('resultsContent');
                    if (resultsContent) {
                        resultsContent.innerHTML = '';
                        console.log('🗑️ Cleared execution results');
                    }
                    
                    // Clear execution logs
                    const executionLogs = document.getElementById('executionLogs');
                    if (executionLogs) {
                        executionLogs.innerHTML = '<div style="text-align: center; color: rgba(255, 130, 40, 0.5); padding: 2rem;">No execution logs available yet. Run a workflow to see detailed logs.</div>';
                        console.log('🗑️ Cleared execution logs');
                    }
                    
                    // Clear cached inputs
                    clearCachedInputs();
                    console.log('🗑️ Cleared cached inputs for different workflow');
                    
                    // Reset to results tab
                    switchTab('results');
                } else if (!previousWorkflow) {
                    // First workflow load - clear any stale state
                    console.log('🔄 First workflow load - clearing any stale state');
                    clearExecutionStatus();
                    const resultsContent = document.getElementById('resultsContent');
                    if (resultsContent) {
                        resultsContent.innerHTML = '';
                    }
                } else {
                    console.log('🔄 Keeping cached inputs and results for same workflow');
                }
                console.log('📋 Full workflow data:', workflow);
                
                updateWorkflowInfo(workflow);
                renderWorkflow(workflow);
                showWorkflowView();
            } else {
                console.log('❌ No workflow data received (null workflow)');
                hideWorkflowInfo();
                showEmptyState();
            }
            
            updateButtons();
        }

        function updateWorkflowInfo(workflow) {
            // Update workflow info elements if they exist (some removed in layout restructure)
            const workflowTitle = document.getElementById('workflowTitle');
            const nodeCount = document.getElementById('nodeCount');  
            const edgeCount = document.getElementById('edgeCount');
            const revNumber = document.getElementById('revNumber');
            
            if (workflowTitle) workflowTitle.textContent = workflow.title;
            if (nodeCount) nodeCount.textContent = workflow.nodes.length;
            if (edgeCount) edgeCount.textContent = workflow.edges.length;
            if (revNumber) revNumber.textContent = workflow.rev;
            
            showBottomPanel();
        }
        
        function hideWorkflowInfo() {
            hideBottomPanel();
        }
        
        

        function updateButtons() {
            const buttons = ['clearBtn', 'executeBtn', 'saveBtn', 'exportBtn', 'runWithInputsBtn'];
            
            buttons.forEach(buttonId => {
                const button = document.getElementById(buttonId);
                if (button) {
                    button.disabled = !currentWorkflow;
                }
            });
            
            // Show/hide the "Run with Inputs" button based on whether workflow has user input tools
            const runWithInputsBtn = document.getElementById('runWithInputsBtn');
            if (runWithInputsBtn) {
                const hasUserInputTools = detectUserInputFormsInWorkflow(currentWorkflow);
                if (hasUserInputTools) {
                    runWithInputsBtn.style.display = 'inline-block';
                    runWithInputsBtn.disabled = !currentWorkflow;
                } else {
                    runWithInputsBtn.style.display = 'none';
                }
            }
        }
        
        function setExecutionLoading(loading) {
            const executeBtn = document.getElementById('executeBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            if (executeBtn) {
                executeBtn.disabled = loading || !currentWorkflow;
                if (loading) {
                    executeBtn.innerHTML = '🚀 Running';
                    executeBtn.classList.add('loading');
                } else {
                    executeBtn.innerHTML = 'Run';
                    executeBtn.classList.remove('loading');
                }
            }
            
            if (stopBtn) {
                stopBtn.disabled = !currentExecution;
            }
        }

        function showExecutionStatus() {
            console.log('🚨 showExecutionStatus called');
            
            // Ensure bottom panel is visible
            const bottomPanel = document.getElementById('bottomPanel');
            if (bottomPanel) {
                bottomPanel.style.display = 'grid';
                console.log('✅ Bottom panel made visible');
            }
            
            // Show sticky execution status section
            const executionStatusSticky = document.getElementById('executionStatusSticky');
            const executionSpinner = document.getElementById('executionSpinner');
            
            if (executionStatusSticky) {
                executionStatusSticky.style.display = 'block';
                console.log('✅ Sticky execution status section made visible');
            } else {
                console.error('❌ Sticky execution status section not found');
            }
            
            if (executionSpinner && currentExecution && currentExecution.status === 'running') {
                executionSpinner.style.display = 'inline';
                console.log('✅ Execution spinner made visible');
            }
        }

        function hideExecutionStatus() {
            const executionStatusSticky = document.getElementById('executionStatusSticky');
            const executionSpinner = document.getElementById('executionSpinner');
            
            if (executionStatusSticky) {
                executionStatusSticky.style.display = 'none';
            }
            
            if (executionSpinner) {
                executionSpinner.style.display = 'none';
            }
        }

        function startRuntimeUpdates() {
            // Clear any existing interval
            if (runtimeUpdateInterval) {
                clearInterval(runtimeUpdateInterval);
            }
            
            // Update runtime every second while execution is running
            runtimeUpdateInterval = setInterval(() => {
                if (currentExecution && currentExecution.status === 'running') {
                    updateExecutionInfo(); // This will recalculate and display the runtime
                } else {
                    // Stop updates if execution is no longer running
                    clearInterval(runtimeUpdateInterval);
                    runtimeUpdateInterval = null;
                }
            }, 1000);
        }

        // Merged clearExecutionStatus function (removed duplicate at line 3817)
        function clearExecutionStatus() {
            currentExecution = null;
            executionTasks = {};
            
            // Stop runtime updates
            if (runtimeUpdateInterval) {
                clearInterval(runtimeUpdateInterval);
                runtimeUpdateInterval = null;
            }
            
            hideExecutionStatus();
            
            // Hide/clear UI elements
            const executionStatusSticky = document.getElementById('executionStatusSticky');
            const resultsScrollArea = document.getElementById('resultsScrollArea');
            const stopBtn = document.getElementById('stopBtn');
            
            if (executionStatusSticky) {
                executionStatusSticky.style.display = 'none';
            }
            if (resultsScrollArea) {
                resultsScrollArea.style.display = 'none';
            }
            if (stopBtn) {
                stopBtn.disabled = true;
            }
            
            setExecutionLoading(false);
        }
        
        function handleExecutionUpdate(data) {
            console.log('🔄 Execution update:', data);
            
            if (!currentExecution || currentExecution.id !== data.execution_id) {
                console.log('Ignoring update for unknown execution');
                return;
            }
            
            currentExecution.status = data.status;
            console.log('🔄 Status updated to:', data.status);
            
            // Add end time when execution completes
            if (data.status === 'completed' || data.status === 'failed') {
                currentExecution.end_time = new Date().toISOString();
                console.log('⏰ Set end_time for completed execution');
                
                // Stop runtime updates when execution finishes
                if (runtimeUpdateInterval) {
                    clearInterval(runtimeUpdateInterval);
                    runtimeUpdateInterval = null;
                }
            }
            
            // Control spinner based on execution status
            const executionSpinner = document.getElementById('executionSpinner');
            if (executionSpinner) {
                if (data.status === 'running') {
                    executionSpinner.style.display = 'inline';
                } else {
                    executionSpinner.style.display = 'none';
                }
            }
            
            if (data.results) {
                currentExecution.results = data.results;
                
                // Handle task-level updates
                if (data.results.current_task) {
                    const taskName = data.results.current_task;
                    const taskStatus = data.results.status;
                    const taskResult = data.results.result;
                    
                    if (!executionTasks[taskName]) {
                        executionTasks[taskName] = {};
                    }
                    
                    executionTasks[taskName].status = taskStatus;
                    if (taskResult !== undefined) {
                        executionTasks[taskName].result = taskResult;
                    }
                    
                    updateTaskDisplay(taskName, taskStatus, taskResult);
                }
            }
            
            if (data.error) {
                currentExecution.error = data.error;
            }
            
            console.log('📊 Calling updateExecutionInfo with currentExecution:', currentExecution);
            updateExecutionInfo();
            
            // Show results if completed
            if (data.status === 'completed' && data.results) {
                console.log('📊 Completion data.results keys:', Object.keys(data.results));
                console.log('📊 Has execution_summary?', 'execution_summary' in data.results);
                
                // Handle both typed and legacy result formats
                // Typed execution returns results directly, legacy wraps in results.results
                const resultsToShow = data.results.results ? data.results : { results: data.results };
                showExecutionResults(resultsToShow);
                
                // Update execution logs immediately if available
                if (data.results.execution_summary) {
                    console.log('📊 Execution summary available, updating logs immediately');
                    executionLogs = data.results.execution_summary;
                    updateExecutionLogs(data.results.execution_summary);
                } else {
                    console.log('⚠️ No execution_summary in results');
                }
                
                // Don't re-render after completion to preserve user input in textareas
                // The re-render was causing user input to be cleared
                // Only re-render if we're awaiting input
            }
            
            // Re-render the workflow to show any user input forms in nodes
            if (currentWorkflow && data.status === 'awaiting_input') {
                console.log('🔄 Re-rendering workflow to show user input forms');
                handleWorkflowUpdate(currentWorkflow);
            }
            
            // Handle completion or failure
            if (data.status === 'completed' || data.status === 'failed') {
                setExecutionLoading(false);
                const stopBtn = document.getElementById('stopBtn');
                if (stopBtn) {
                    stopBtn.disabled = true;
                }
                
                // Update all remaining running tasks to completed/failed when workflow finishes
                for (const [taskName, task] of Object.entries(executionTasks)) {
                    if (task.status === 'started' || task.status === 'running') {
                        // Mark task as completed if workflow succeeded, or failed if workflow failed
                        executionTasks[taskName].status = data.status === 'completed' ? 'completed' : 'failed';
                        console.log(`🔄 Updated task ${taskName} status to ${executionTasks[taskName].status} due to workflow completion`);
                    }
                }
                
                // Refresh display to show updated task statuses
                updateExecutionInfo();
                
                // Execution feedback now comes via WebSocket as a chat_message
                // No need to poll the API anymore
            }
        }
        
        async function fetchAndDisplayExecutionFeedback(executionId) {
            try {
                // Wait a moment for backend to process feedback
                setTimeout(async () => {
                    const response = await fetch(`/api/executions/${executionId}/feedback`);
                    
                    if (!response.ok) {
                        console.log('📊 No feedback available yet');
                        return;
                    }
                    
                    const feedbackData = await response.json();
                    console.log('📊 Execution feedback received:', feedbackData);
                    console.log('📊 Planner feedback exists:', !!feedbackData.planner_feedback);
                    console.log('📊 Planner feedback type:', typeof feedbackData.planner_feedback);
                    console.log('📊 Planner feedback preview:', feedbackData.planner_feedback ? feedbackData.planner_feedback.substring(0, 100) + '...' : 'null/undefined');
                    
                    // Store execution logs for the logs tab
                    if (feedbackData.execution_summary) {
                        executionLogs = feedbackData.execution_summary;
                        updateExecutionLogs(feedbackData.execution_summary);
                    }
                    
                    // Only display AI analysis/feedback if available (skip raw report to avoid duplication)
                    if (feedbackData.planner_feedback) {
                        console.log('📊 Adding planner feedback to chat');
                        // Add the AI analysis with execution context
                        addMessageToChat(feedbackData.planner_feedback, 'assistant', { isExecutionReport: true });
                        
                        // Add a prompt for user to ask for improvements if there were issues
                        if (feedbackData.execution_metrics && feedbackData.execution_metrics.success_rate < 100) {
                            addMessageToChat(
                                '💡 Would you like me to create an improved version of this workflow based on the issues identified?', 
                                'assistant'
                            );
                        }
                    } else if (feedbackData.curated_summary) {
                        // Fallback to raw report only if no AI analysis available
                        addMessageToChat(feedbackData.curated_summary, 'system', { isExecutionReport: true });
                    }
                }, 5000); // Wait 5 seconds for backend processing (increased from 2s)
                
            } catch (error) {
                console.error('❌ Error fetching execution feedback:', error);
            }
        }
        
        
        function updateExecutionInfo() {
            console.log('🚨🚨🚨 updateExecutionInfo called', currentExecution);
            if (!currentExecution) {
                console.log('❌❌❌ No currentExecution - cannot update execution info');
                return;
            }
            console.log('🔍🔍🔍 Current execution status:', currentExecution.status);
            console.log('🔍🔍🔍 Has start_time:', !!currentExecution.start_time);
            
            // Ensure the sticky status section is visible
            const executionStatusSticky = document.getElementById('executionStatusSticky');
            if (executionStatusSticky) {
                executionStatusSticky.style.display = 'block';
            }
            
            const statusClass = `status-${currentExecution.status}`;
            const statusText = currentExecution.status.charAt(0).toUpperCase() + currentExecution.status.slice(1);
            
            // Enhanced status text with thinking indicators
            let enhancedStatusText = statusText;
            if (currentExecution.status === 'running') {
                enhancedStatusText = `${statusText} <span class="thinking-indicator"></span>`;
            }

            // Create cockpit-style compact header
            const headerInfo = document.getElementById('executionHeaderInfo');
            const detailsInfo = document.getElementById('executionInfo');
            
            // Also show the results section when execution info is updated
            const resultsSection = document.getElementById('executionResults');
            if (resultsSection) {
                resultsSection.style.display = 'flex';
            }
            
            if (headerInfo) {
                // Compact terminal-style header
                const successCount = Object.values(executionTasks).filter(t => t.status === 'completed').length;
                const totalTasks = Object.keys(executionTasks).length;
                const failedCount = Object.values(executionTasks).filter(t => t.status === 'failed').length;
                const execId = currentExecution.id.substring(0, 8);
                const status = currentExecution.status;
                
                const statusColor = status === 'completed' ? 'log-success' : 
                                   status === 'running' ? 'log-warning' : 
                                   status === 'failed' ? 'log-error' : 'log-dim';
                
                const workflowTitleText = (currentExecution.workflow_title || '').substring(0, 40);
                
                // Calculate runtime
                let runtimeDisplay = '';
                if (currentExecution.start_time) {
                    const startTime = new Date(currentExecution.start_time);
                    const currentTime = status === 'completed' && currentExecution.end_time ? 
                                       new Date(currentExecution.end_time) : new Date();
                    const runtimeSeconds = (currentTime - startTime) / 1000;
                    runtimeDisplay = ` <span class="log-dim">|</span> <span class="runtime-display">${runtimeSeconds.toFixed(1)}s</span>`;
                }
                
                // Add animated indicators for running status and completion messages
                let statusDisplay = status.toUpperCase();
                if (status === 'running') {
                    console.log('🚨🚨🚨 STATUS IS RUNNING - GENERATING ANIMATION HTML');
                    statusDisplay = `<span class="running-indicator"><span class="running-spinner"></span>RUNNING<span class="running-dots"></span></span>`;
                    console.log('🚨🚨🚨 Running statusDisplay HTML:', statusDisplay);
                } else if (status === 'completed' && currentExecution.start_time && currentExecution.end_time) {
                    // Show completion message with total runtime
                    const startTime = new Date(currentExecution.start_time);
                    const endTime = new Date(currentExecution.end_time);
                    const totalSeconds = (endTime - startTime) / 1000;
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = (totalSeconds % 60).toFixed(1);
                    const timeDisplay = minutes > 0 ? `${minutes}m${seconds}s` : `${seconds}s`;
                    statusDisplay = `✅ COMPLETED in ${timeDisplay}`;
                    console.log('✅ Generated completion message:', statusDisplay);
                } else {
                    console.log('📊 Status display for:', status);
                }
                
                let headerHTML = '<span class="log-dim">─────────────────────────────────────────────────────────────────────</span>\n';
                headerHTML += `<span class="log-highlight">exec:</span> ${execId} <span class="log-dim">|</span> <span class="${statusColor}">${statusDisplay}</span>${runtimeDisplay} <span class="log-dim">|</span> <span class="log-node-id">${workflowTitleText}</span>\n`;
                headerHTML += `<span class="log-dim">tasks:</span> <span class="log-success">${successCount}/${totalTasks}</span> ok <span class="log-dim">|</span> <span class="log-error">${failedCount}</span> fail <span class="log-dim">|</span> <span class="log-warning">${totalTasks - successCount - failedCount}</span> pending\n`;
                
                // Add user inputs in the header if any
                if (Object.keys(cachedUserInputs).length > 0) {
                    const userInputText = Object.entries(cachedUserInputs)
                        .map(([k, v]) => {
                            const cleanValue = String(v).substring(0, 40);
                            return `${k}:"${cleanValue}${v.length > 40 ? '...' : ''}"`;
                        })
                        .join(' ');
                    headerHTML += `<span class="log-highlight">input:</span> <span class="log-dim">${userInputText}</span>\n`;
                }
                
                headerHTML += '<span class="log-dim">─────────────────────────────────────────────────────────────────────</span>';
                
                console.log('🚨🚨🚨 SETTING headerHTML:', headerHTML);
                headerInfo.innerHTML = headerHTML;
                console.log('🚨🚨🚨 AFTER SETTING - headerInfo.innerHTML:', headerInfo.innerHTML);
                
                // Also update workflow info in header
                const workflowTitle = document.getElementById('workflowTitle');
                const nodeCount = document.getElementById('nodeCount');
                const edgeCount = document.getElementById('edgeCount');
                const revNumber = document.getElementById('revNumber');
                
                if (currentWorkflow && workflowTitle && nodeCount && edgeCount && revNumber) {
                    // Update title elements but keep them hidden - info is in compact header
                    workflowTitle.textContent = currentWorkflow.title;
                    nodeCount.textContent = currentWorkflow.nodes.length;
                    edgeCount.textContent = currentWorkflow.edges.length;
                    revNumber.textContent = currentWorkflow.rev;
                }
                console.log('🚨🚨🚨 headerInfo element:', headerInfo);
                console.log('🚨🚨🚨 headerInfo visible?', headerInfo.offsetWidth > 0 && headerInfo.offsetHeight > 0);
                
                // Force a reflow and check if animation elements exist
                setTimeout(() => {
                    const spinnerElements = document.querySelectorAll('.running-spinner');
                    const indicatorElements = document.querySelectorAll('.running-indicator'); 
                    console.log('🚨🚨🚨 After timeout - spinner elements found:', spinnerElements.length);
                    console.log('🚨🚨🚨 After timeout - indicator elements found:', indicatorElements.length);
                    if (spinnerElements.length > 0) {
                        console.log('🚨🚨🚨 First spinner element:', spinnerElements[0]);
                        console.log('🚨🚨🚨 First spinner computed style display:', window.getComputedStyle(spinnerElements[0]).display);
                        console.log('🚨🚨🚨 First spinner computed style visibility:', window.getComputedStyle(spinnerElements[0]).visibility);
                    }
                }, 100);
            }
            
            // Detailed task progress in the details section
            let infoHTML = '';
            
            if (currentExecution.error) {
                infoHTML += `
                    <div class="detail-row" style="margin-top: 0.5rem;">
                        <span style="color: #dc3545; font-weight: bold;">Error:</span>
                    </div>
                    <div style="background: #f8d7da; color: #721c24; padding: 0.5rem; border-radius: 4px; margin-top: 0.25rem; font-size: 0.8rem;">
                        ${currentExecution.error}
                    </div>
                `;
            }
            
            // Task progress display removed - redundant with header display
            
            if (detailsInfo) {
                detailsInfo.innerHTML = infoHTML;
            }
        }
        
        function updateTaskDisplay(taskName, status, result) {
            // This is called for real-time task updates
            console.log(`📋 Task Update: ${taskName} - ${status}`, result);
            updateExecutionInfo(); // Refresh the entire display
        }
        
        function showExecutionResults(results) {
            const resultsContent = document.getElementById('resultsContent');
            
            let resultsHTML = '';
            
            // Enhanced results display with data science styling
            if (results.results && typeof results.results === 'object') {
                resultsHTML = '<div class="enhanced-results">';
                
                // Process each task result with modal cards
                for (const [taskKey, taskResult] of Object.entries(results.results)) {
                    const taskNode = currentWorkflow?.nodes?.find(n => n.id === taskKey);
                    const nodeType = taskNode?.type || 'unknown';
                    const nodeLabel = taskNode?.label || taskKey;
                    const isAgentTask = nodeType === 'agent';
                    const agentTools = taskNode?.data?.tools || [];
                    
                    // Create data science modal for each node
                    resultsHTML += '<div class="node-result-modal">';
                    
                    // Node header with metrics
                    const nodeIcon = isAgentTask ? '🤖' : nodeType === 'tool' ? '🔧' : '📊';
                    
                    // Check for SLA information for decision agents
                    let slaBadge = '';
                    if (isAgentTask && currentWorkflow && currentWorkflow.nodes) {
                        const workflowNode = currentWorkflow.nodes.find(n => n.id === taskKey);
                        if (workflowNode && workflowNode.sla && workflowNode.sla.enforce_usage) {
                            const sla = workflowNode.sla;
                            if (sla.final_tool_must_be && sla.required_tools && sla.required_tools.length > 0) {
                                slaBadge = ` <span class="sla-badge decision">🎯 DECISION</span>`;
                            } else if (sla.required_tools && sla.required_tools.length > 0) {
                                slaBadge = ` <span class="sla-badge strict">🎯 STRICT</span>`;
                            } else {
                                slaBadge = ` <span class="sla-badge basic">🎯 SLA</span>`;
                            }
                        }
                    }
                    
                    resultsHTML += `
                        <div class="node-result-header">
                            <span class="node-result-icon">${nodeIcon}</span>
                            <span class="node-result-title">${nodeLabel}${slaBadge}</span>
                            <span class="node-result-type">${nodeType}</span>
                        </div>
                    `;
                    
                    // Calculate metrics
                    const executionTime = executionTasks[taskKey]?.duration || 'N/A';
                    const toolsUsed = agentTools.length;
                    const resultSize = JSON.stringify(taskResult).length;
                    
                    // Store metrics info for later consolidation with data insights
                    const executionMetrics = {
                        executionTime: executionTime !== 'N/A' ? executionTime : null,
                        toolsUsed: isAgentTask && toolsUsed > 0 ? toolsUsed : null,
                        resultSize: resultSize
                    };
                    
                    // Check for actual tool usage from execution results - multiple sources
                    const nodeTaskResult = executionTasks[taskKey];
                    let actualToolUsage = [];
                    
                    // Try multiple sources for tool usage data
                    if (results.tool_usage && results.tool_usage[taskKey]) {
                        actualToolUsage = results.tool_usage[taskKey];
                        console.log('🛠️ Found tool usage in results.tool_usage[taskKey]:', actualToolUsage);
                    } else if (taskResult && taskResult.agent_response && taskResult.agent_response.tool_usage_results) {
                        // Typed AgentExecutionResult format
                        actualToolUsage = taskResult.agent_response.tool_usage_results;
                        console.log('🛠️ Found tool usage in typed format taskResult.agent_response.tool_usage_results:', actualToolUsage);
                    } else if (taskResult && taskResult.tool_usage_results) {
                        actualToolUsage = taskResult.tool_usage_results;
                        console.log('🛠️ Found tool usage in taskResult.tool_usage_results:', actualToolUsage);
                    } else if (taskResult && taskResult.tool_usage) {
                        actualToolUsage = taskResult.tool_usage;
                        console.log('🛠️ Found tool usage in taskResult.tool_usage:', actualToolUsage);
                    } else if (nodeTaskResult && nodeTaskResult.tool_usage_results) {
                        actualToolUsage = nodeTaskResult.tool_usage_results;
                        console.log('🛠️ Found tool usage in nodeTaskResult.tool_usage_results:', actualToolUsage);
                    } else if (nodeTaskResult && nodeTaskResult.tool_usage) {
                        actualToolUsage = nodeTaskResult.tool_usage;
                        console.log('🛠️ Found tool usage in nodeTaskResult.tool_usage:', actualToolUsage);
                    } else {
                        // Check the entire results object for tool usage patterns
                        const resultString = JSON.stringify(taskResult);
                        if (resultString && (resultString.includes('tool_name') || resultString.includes('tool_usage'))) {
                            console.log('🛠️ Detected tool usage patterns in result string, parsing manually...');
                            try {
                                // Try to extract tool usage from nested result structure
                                if (taskResult && typeof taskResult === 'object') {
                                    const findToolUsage = (obj, path = '') => {
                                        if (Array.isArray(obj) && obj.length > 0 && obj[0].tool_name) {
                                            return obj;
                                        }
                                        if (typeof obj === 'object' && obj !== null) {
                                            for (const [key, value] of Object.entries(obj)) {
                                                if (key === 'tool_usage' && Array.isArray(value)) {
                                                    return value;
                                                }
                                                const result = findToolUsage(value, path + '.' + key);
                                                if (result) return result;
                                            }
                                        }
                                        return null;
                                    };
                                    const foundUsage = findToolUsage(taskResult);
                                    if (foundUsage) {
                                        actualToolUsage = foundUsage;
                                        console.log('🛠️ Found tool usage via deep search:', actualToolUsage);
                                    }
                                }
                            } catch (e) {
                                console.log('🛠️ Error parsing tool usage:', e);
                            }
                        }
                    }
                    
                    console.log('🛠️ Final actualToolUsage for', taskKey, ':', actualToolUsage);
                    
                    // Show actual tool usage if available - CYBERPUNK PILL STYLE
                    if (actualToolUsage.length > 0) {
                        resultsHTML += '<div class="tools-grid">';
                        console.log('✅ Adding cyberpunk tool pills for', actualToolUsage.length, 'tools');
                        
                        actualToolUsage.forEach(toolUsage => {
                            // Check for success in different possible properties
                            const isSuccess = toolUsage.success !== false && !toolUsage.error && toolUsage.tool_result !== undefined;
                            const status = isSuccess ? '🔧' : '⚠️';
                            const statusClass = isSuccess ? 'success' : 'error';
                            const toolArgs = toolUsage.args || toolUsage.tool_args;
                            const toolResult = toolUsage.result || toolUsage.tool_result;
                            
                            // Format JSON as clean readable text
                            const formatData = (data) => {
                                if (!data) return 'none';
                                try {
                                    if (typeof data === 'object') {
                                        return JSON.stringify(data, null, 2);
                                    }
                                    return String(data);
                                } catch (e) {
                                    return String(data);
                                }
                            };
                            
                            resultsHTML += `
                                <div class="tool-pill-expanded ${statusClass}" onclick="toggleToolDetails(this)">
                                    <div class="tool-pill-header">
                                        <span class="tool-status">${status}</span>
                                        <span class="tool-name">${toolUsage.tool_name}</span>
                                        <span class="tool-expand">▼</span>
                                    </div>
                                    <div class="tool-details">
                                        ${toolArgs ? `<div class="tool-section">
                                            <div class="tool-label">Args</div>
                                            <pre class="tool-data">${formatData(toolArgs)}</pre>
                                        </div>` : ''}
                                        ${toolResult ? `<div class="tool-section">
                                            <div class="tool-label">Result</div>
                                            <pre class="tool-data">${formatData(toolResult)}</pre>
                                        </div>` : ''}
                                    </div>
                                </div>
                            `;
                        });
                        resultsHTML += '</div>';
                    } else if (isAgentTask && agentTools.length > 0) {
                        // Show available tools if no actual usage recorded
                        resultsHTML += '<div class="tool-usage-pills">';
                        resultsHTML += '<h4>🔧 Available Tools:</h4>';
                        agentTools.forEach(tool => {
                            resultsHTML += `<span class="tool-pill available">${tool}</span>`;
                        });
                        resultsHTML += '</div>';
                    }
                    
                    // Result content
                    resultsHTML += '<div class="node-result-content">';
                    
                    // Format result content with data science styling
                    let resultText = '';
                    if (typeof taskResult === 'object' && taskResult !== null) {
                        // Handle typed execution results (AgentExecutionResult with nested agent_response.result)
                        let mainResult;
                        if (taskResult.agent_response && taskResult.agent_response.result !== undefined) {
                            // Typed AgentExecutionResult format
                            mainResult = taskResult.agent_response.result;
                        } else {
                            // Legacy format or direct result
                            mainResult = taskResult.result || taskResult.output || taskResult;
                        }
                        
                        if (typeof mainResult === 'string') {
                            resultText = mainResult;
                        } else {
                            resultText = JSON.stringify(mainResult, null, 2);
                        }
                    } else {
                        resultText = String(taskResult);
                    }
                    
                    resultsHTML += resultText;
                    resultsHTML += '</div>'; // Close node-result-content
                    
                    // Add consolidated data insights pill with ALL metrics
                    const charCount = resultText.length;
                    const lineCount = (resultText.match(/\n/g) || []).length + 1;
                    const wordCount = (resultText.match(/\w+/g) || []).length;
                    
                    // Build consolidated metrics array
                    let allMetrics = [];
                    if (executionMetrics.executionTime) {
                        allMetrics.push(`${executionMetrics.executionTime}s`);
                    }
                    if (executionMetrics.toolsUsed) {
                        allMetrics.push(`${executionMetrics.toolsUsed}t`);
                    }
                    // Add size in better format
                    let sizeDisplay = executionMetrics.resultSize > 1024 ? `${Math.round(executionMetrics.resultSize/1024)}k` : `${executionMetrics.resultSize}b`;
                    allMetrics.push(sizeDisplay);
                    allMetrics.push(`${charCount}c`);
                    allMetrics.push(`${lineCount}l`);
                    allMetrics.push(`${wordCount}w`);
                    
                    resultsHTML += `<span class="data-insights-pill">📊 ${allMetrics.join(' | ')}</span>`;
                    
                    resultsHTML += '</div>'; // Close node-result-modal
                }
                
                resultsHTML += '</div>'; // Close enhanced-results
            } else {
                // Fallback to original JSON display
                const jsonString = results.results ? JSON.stringify(results.results, null, 2) : JSON.stringify(results, null, 2);
                resultsHTML = `<div class="node-result-modal">
                    <div class="node-result-header">
                        <span class="node-result-icon">📊</span>
                        <span class="node-result-title">Workflow Results</span>
                        <span class="node-result-type">raw</span>
                    </div>
                    <div class="node-result-content">${jsonString}</div>
                </div>`;
            }
            
            if (resultsContent) {
                console.log('🎆 Setting results content HTML length:', resultsHTML.length);
                resultsContent.innerHTML = resultsHTML;
                console.log('✅ Results content updated');
                
                // Show the scroll area
                const scrollArea = document.getElementById('resultsScrollArea');
                if (scrollArea) {
                    scrollArea.style.display = 'flex';
                }
            } else {
                console.error('❌ Results content div not found');
            }
        }

        function showEmptyState() {
            document.getElementById('emptyState').style.display = 'flex';
            document.getElementById('flowContainer').style.display = 'none';
        }

        function showWorkflowView() {
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('flowContainer').style.display = 'block';
        }

        // React Flow state management
        let currentNodes = [];
        let currentEdges = [];
        
        // Instructions toggle function
        function toggleInstructions(nodeId) {
            const preview = document.getElementById(`preview-${nodeId}`);
            const full = document.getElementById(`full-${nodeId}`);
            
            if (preview && full) {
                if (full.style.display === 'none') {
                    preview.style.display = 'none';
                    full.style.display = 'block';
                } else {
                    preview.style.display = 'block';
                    full.style.display = 'none';
                }
            }
        }

        // React Flow rendering with rich node display
        function renderWorkflow(workflow) {
            console.log('🎨 renderWorkflow called with:', workflow);
            const container = document.getElementById('flowContainer');
            
            // Convert workflow to React Flow format with rich node content
            console.log('🔄 Converting nodes:', workflow.nodes);
            console.log('🔍 Current execution results:', currentExecution);
            if (currentExecution && currentExecution.results) {
                console.log('🔍 Available result node IDs:', Object.keys(currentExecution.results.results || {}));
            }
            currentNodes = workflow.nodes.map((node, index) => {
                // Create rich HTML content for the node with new styling
                const nodeIcon = getNodeIcon(node.type, node.data);
                
                // Get semantic node type badge
                const getNodeTypeBadge = (nodeType, nodeData) => {
                    const badges = {
                        'tool': { emoji: '🔧', label: 'TOOL', color: 'rgba(100, 255, 100, 0.2)', border: 'rgba(100, 255, 100, 0.8)' },
                        'decision': { emoji: '🎯', label: 'DECISION', color: 'rgba(255, 165, 0, 0.2)', border: 'rgba(255, 165, 0, 0.8)' },
                        'data_fetcher': { emoji: '📡', label: 'FETCH', color: 'rgba(0, 191, 255, 0.2)', border: 'rgba(0, 191, 255, 0.8)' },
                        'analyzer': { emoji: '🔍', label: 'ANALYZE', color: 'rgba(138, 43, 226, 0.2)', border: 'rgba(138, 43, 226, 0.8)' },
                        'executor': { emoji: '⚡', label: 'EXECUTE', color: 'rgba(255, 69, 0, 0.2)', border: 'rgba(255, 69, 0, 0.8)' },
                        'conversational': { emoji: '💬', label: 'CHAT', color: 'rgba(255, 20, 147, 0.2)', border: 'rgba(255, 20, 147, 0.8)' },
                        'workflow_call': { emoji: '📞', label: 'WORKFLOW', color: 'rgba(148, 0, 211, 0.2)', border: 'rgba(148, 0, 211, 0.8)' },
                        'agent': { emoji: '🤖', label: 'AGENT', color: 'rgba(255, 130, 40, 0.2)', border: 'rgba(255, 130, 40, 0.8)' }
                    };
                    
                    const badge = badges[nodeType] || badges['agent'];
                    return `<span class="node-type-badge" style="
                        display: inline-flex;
                        align-items: center;
                        background: ${badge.color};
                        border: 1px solid ${badge.border};
                        border-radius: 12px;
                        padding: 2px 8px;
                        margin-left: 8px;
                        font-size: 10px;
                        font-weight: 700;
                        color: ${badge.border};
                        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                    ">${badge.emoji} ${badge.label}</span>`;
                };

                let nodeContent = `
                    <div class="node-content" style="padding: 12px; min-width: 200px;">
                        <div class="node-title">
                            ${nodeIcon} ${node.label}
                            ${getNodeTypeBadge(node.type, node.data)}
                        </div>
                        <div class="node-id">
                            ${node.id}
                        </div>
                `;
                
                // Add type-specific information
                if (node.type === 'agent' && node.data.agent_instructions) {
                    const fullInstructions = node.data.agent_instructions;
                    const preview = fullInstructions.length > 80 ? 
                        fullInstructions.substring(0, 80) + '...' : 
                        fullInstructions;
                    
                    nodeContent += `
                        <div class="node-instructions ${fullInstructions.length > 80 ? 'node-instructions-expandable' : ''}" 
                             title="${fullInstructions.replace(/"/g, '&quot;')}"
                             onclick="toggleInstructions('${node.id}')">
                            <div class="instructions-preview" id="preview-${node.id}">
                                📋 ${preview}
                            </div>
                            ${fullInstructions.length > 80 ? `
                            <div class="instructions-full" id="full-${node.id}" style="display: none;">
                                📋 ${fullInstructions}
                            </div>
                            ` : ''}
                        </div>
                        ${getExecutionModeIndicator(node.data)}
                    `;
                    
                    // Add model information for agent nodes
                    if (node.data.model) {
                        nodeContent += `
                            <div class="node-model" style="margin-top: 4px; font-size: 11px; color: #666;">
                                🤖 ${node.data.model}
                            </div>
                        `;
                    }
                    
                    // Add tool pills for agent nodes
                    if (node.data.tools && node.data.tools.length > 0) {
                        const toolPills = node.data.tools.map(tool => {
                            // Highlight routing tools with special styling
                            const isRoutingTool = ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'].includes(tool);
                            return `<span class="tool-pill ${isRoutingTool ? 'routing-tool' : ''}">🔧${tool}</span>`;
                        }).join(' ');
                        nodeContent += `
                            <div style="margin-top: 6px;">
                                ${toolPills}
                            </div>
                        `;
                    }
                    
                    // Add enhanced SLA status display for nodes with SLA requirements
                    console.log(`🔍 Node ${node.id} SLA check:`, node.sla);
                    if (node.sla && node.sla.enforce_usage) {
                        const sla = node.sla;
                        const slaType = getSLAType(sla, node.data.tools);
                        console.log(`✅ Node ${node.id} has SLA enforcement:`, slaType, sla);
                        
                        // Generate enhanced SLA pill with detailed information
                        const slaPills = generateSLAPills(sla, node.data.tools);
                        nodeContent += `
                            <div class="sla-indicators" style="margin-top: 6px; display: flex; flex-wrap: wrap; gap: 4px;">
                                ${slaPills.join('')}
                            </div>
                        `;
                    } else {
                        console.log(`❌ Node ${node.id} has no SLA enforcement`);
                    }
                } else if (node.type === 'decision') {
                    // Handle decision nodes - they have agent_instructions, tools, and SLA like agent nodes
                    if (node.data.agent_instructions) {
                        const fullInstructions = node.data.agent_instructions;
                        const preview = fullInstructions.length > 80 ? 
                            fullInstructions.substring(0, 80) + '...' : 
                            fullInstructions;
                        
                        nodeContent += `
                            <div class="node-instructions ${fullInstructions.length > 80 ? 'node-instructions-expandable' : ''}" 
                                 title="${fullInstructions.replace(/"/g, '&quot;')}"
                                 onclick="toggleInstructions('${node.id}')">
                                <div class="instructions-preview" id="preview-${node.id}">
                                    📋 ${preview}
                                </div>
                                ${fullInstructions.length > 80 ? `
                                <div class="instructions-full" id="full-${node.id}" style="display: none;">
                                    📋 ${fullInstructions}
                                </div>
                                ` : ''}
                            </div>
                            ${getExecutionModeIndicator(node.data)}
                        `;
                    }
                    
                    // Add model information for decision nodes
                    if (node.data.model) {
                        nodeContent += `
                            <div class="node-model" style="margin-top: 4px; font-size: 11px; color: #666;">
                                🤖 ${node.data.model}
                            </div>
                        `;
                    }
                    
                    // Add tool pills for decision nodes
                    if (node.data.tools && node.data.tools.length > 0) {
                        const toolPills = node.data.tools.map(tool => {
                            // Highlight routing tools with special styling
                            const isRoutingTool = ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'].includes(tool);
                            return `<span class="tool-pill ${isRoutingTool ? 'routing-tool' : ''}">🔧${tool}</span>`;
                        }).join(' ');
                        nodeContent += `
                            <div style="margin-top: 6px;">
                                ${toolPills}
                            </div>
                        `;
                    }
                    
                    // Add enhanced SLA status display for nodes with SLA requirements
                    console.log(`🔍 Decision Node ${node.id} SLA check:`, node.sla);
                    if (node.sla && node.sla.enforce_usage) {
                        const sla = node.sla;
                        const slaType = getSLAType(sla, node.data.tools);
                        console.log(`✅ Decision Node ${node.id} has SLA enforcement:`, slaType, sla);
                        
                        // Generate enhanced SLA pill with detailed information
                        const slaPills = generateSLAPills(sla, node.data.tools);
                        nodeContent += `
                            <div class="sla-indicators" style="margin-top: 6px; display: flex; flex-wrap: wrap; gap: 4px;">
                                ${slaPills.join('')}
                            </div>
                        `;
                    } else {
                        console.log(`❌ Decision Node ${node.id} has no SLA enforcement`);
                    }
                } else if (node.type === 'data_source' && node.data.source_name) {
                    nodeContent += `
                        <div class="node-instructions">
                            Source: ${node.data.source_name}
                        </div>
                    `;
                } else if (node.type === 'tool' && node.data.tool_name) {
                    // Backward compatibility
                    nodeContent += `
                        <div class="node-instructions">
                            Tool: ${node.data.tool_name}
                        </div>
                    `;
                }
                
                // Add input/output ports
                const inputPorts = node.data.ins || [];
                const outputPorts = node.data.outs || [];
                
                if (inputPorts.length > 0 || outputPorts.length > 0) {
                    nodeContent += `<div style="margin-top: 8px;">`;
                    
                    if (inputPorts.length > 0) {
                        const inputs = inputPorts.map(p => 
                            `<span class="port-badge input">→${p}</span>`
                        ).join(' ');
                        nodeContent += `<div style="margin-bottom: 3px;">${inputs}</div>`;
                    }
                    
                    if (outputPorts.length > 0) {
                        const outputs = outputPorts.map(p => 
                            `<span class="port-badge output">${p}→</span>`
                        ).join(' ');
                        nodeContent += `<div>${outputs}</div>`;
                    }
                    
                    nodeContent += `</div>`;
                }
                
                // Check if this node should show a user input form
                const shouldShowInput = checkNodeForUserInput(node);
                console.log('🔍 Node', node.id, 'should show input:', shouldShowInput);
                if (shouldShowInput) {
                    // Use enhanced UI for text input tools
                    const toolName = node.data.source_name || node.data.tool_name || 'user_input';
                    if (isTextInputTool(toolName)) {
                        nodeContent += `
                            <div class="user-input-section" style="margin-top: 8px;">
                                ${createEnhancedTextInput(node.id, toolName, node.data.config || {}, '', [], null)}
                            </div>
                        `;
                        // Initialize character counts after DOM update
                        setTimeout(() => initializeCharacterCounts(), 100);
                    } else {
                        // Fallback for non-enhanced tools
                        nodeContent += `
                            <div class="user-input-section" style="margin-top: 8px; padding: 8px; background: rgba(100, 255, 100, 0.1); border-radius: 6px;">
                                <input 
                                    type="text" 
                                    id="input-${node.id}" 
                                    placeholder="${shouldShowInput.placeholder || 'Enter your input...'}"
                                    style="width: 100%; padding: 6px; border: 1px solid rgba(100, 255, 100, 0.5); border-radius: 4px; background: rgba(0,0,0,0.3); color: white;"
                                />
                                <button 
                                    onclick="runWorkflowWithNodeInput('${node.id}')"
                                    style="width: 100%; margin-top: 6px; padding: 6px; background: linear-gradient(135deg, #64FF64, #4CAF50); color: black; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;"
                                >
                                    Run Workflow
                                </button>
                            </div>
                        `;
                    }
                }
                
                nodeContent += `</div>`;
                
                const isDecisionAgent = (node.type === 'agent' && node.data?.tools?.some(t => ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'].includes(t)));
                
                const reactFlowNode = {
                    id: node.id,
                    type: 'default',
                    position: node.position || { x: index * 280, y: index * 120 },
                    data: {
                        label: React.createElement('div', {
                            dangerouslySetInnerHTML: { __html: nodeContent },
                            'data-type': node.type,
                            'data-has-routing-tools': isDecisionAgent ? 'true' : 'false'
                        }),
                        nodeType: node.type,
                        hasRoutingTools: isDecisionAgent
                    },
                    draggable: true,
                    selectable: true,
                    style: {
                        background: 'rgba(30, 60, 90, 0.95)',
                        color: 'white',
                        border: '2px solid rgba(100, 255, 100, 0.4)',
                        borderRadius: '8px',
                        padding: '8px',
                        fontSize: '12px',
                        width: '200px',
                        minHeight: '60px'
                    }
                };
                console.log(`   Node ${index}: ${node.id} -> ReactFlow node:`, reactFlowNode);
                return reactFlowNode;
            });

            console.log('🔄 Converting edges:', workflow.edges);
            currentEdges = workflow.edges.map((edge, index) => {
                // Create rich edge label with connection details
                let edgeLabel = '';
                const sourceHandle = edge.sourceHandle || 'default';
                const targetHandle = edge.targetHandle || 'default';
                
                if (sourceHandle !== 'default' || targetHandle !== 'default') {
                    edgeLabel = `${sourceHandle} → ${targetHandle}`;
                }
                
                if (edge.data?.condition) {
                    edgeLabel = edgeLabel ? `${edgeLabel}\\nif: ${edge.data.condition}` : `if: ${edge.data.condition}`;
                }
                
                const reactFlowEdge = {
                    id: edge.id,
                    source: edge.source,
                    target: edge.target,
                    sourceHandle: edge.sourceHandle,
                    targetHandle: edge.targetHandle,
                    label: edgeLabel,
                    style: { 
                        stroke: 'rgba(100, 255, 100, 0.8)', 
                        strokeWidth: 2,
                        strokeDasharray: edge.data?.condition ? '5,5' : 'none'
                    },
                    labelStyle: { 
                        fontSize: '9px', 
                        fill: 'rgba(100, 255, 100, 1)', 
                        fontWeight: 'bold'
                    },
                    labelBgStyle: { 
                        fill: 'rgba(10, 10, 10, 0.95)', 
                        fillOpacity: 0.9,
                        rx: 4,
                        ry: 4
                    },
                    markerEnd: {
                        type: 'arrowclosed',
                        color: 'rgba(100, 255, 100, 0.8)'
                    }
                };
                console.log(`   Edge ${index}: ${edge.source} -> ${edge.target}:`, reactFlowEdge);
                return reactFlowEdge;
            });

            console.log('📊 Final ReactFlow data:', { currentNodes, currentEdges });

            // Check if ReactFlow is available
            if (typeof ReactFlow === 'undefined') {
                console.error('ReactFlow not loaded properly');
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #666;">React Flow failed to load. Please refresh the page.</div>';
                return;
            }

            console.log('ReactFlow object:', ReactFlow);

            // Create React Flow component using React.createElement
            // Use the hooks from ReactFlow
            const { ReactFlowProvider, applyNodeChanges, applyEdgeChanges } = ReactFlow;
            const ReactFlowComponent = ReactFlow.default || ReactFlow.ReactFlow;
            
            console.log('Using ReactFlow component:', ReactFlowComponent);
            console.log('ReactFlow hooks available:', { ReactFlowProvider, applyNodeChanges, applyEdgeChanges });
            
            if (!ReactFlowComponent) {
                console.error('ReactFlow component not found!');
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #dc3545;">ReactFlow failed to load. Check console for details.</div>';
                return;
            }
            
            // Create a controlled component that manages nodes/edges state
            const FlowApp = function() {
                const [nodes, setNodes] = React.useState(currentNodes);
                const [edges, setEdges] = React.useState(currentEdges);
                
                const onNodesChange = React.useCallback((changes) => {
                    setNodes((nds) => {
                        const updated = applyNodeChanges(changes, nds);
                        console.log('Nodes updated:', changes);
                        return updated;
                    });
                }, []);
                
                const onEdgesChange = React.useCallback((changes) => {
                    setEdges((eds) => applyEdgeChanges(changes, eds));
                }, []);
                
                const onConnect = React.useCallback((connection) => {
                    console.log('New connection:', connection);
                }, []);
                
                const onInit = React.useCallback((instance) => {
                    reactFlowInstance = instance;
                    console.log('ReactFlow initialized with instance:', instance);
                    console.log('fitView available:', typeof instance.fitView);
                    // Fit view after initialization
                    setTimeout(() => instance.fitView({ padding: 0.1 }), 100);
                }, []);
                
                const onNodeDragStart = React.useCallback((event, node) => {
                    console.log('Node drag started:', node.id);
                }, []);
                
                const onNodeDrag = React.useCallback((event, node) => {
                    console.log('Node dragging:', node.id, node.position);
                }, []);
                
                const onNodeDragStop = React.useCallback((event, node) => {
                    console.log('Node drag stopped:', node.id, node.position);
                }, []);
                
                return React.createElement(ReactFlowComponent, {
                    nodes: nodes,
                    edges: edges,
                    onNodesChange: onNodesChange,
                    onEdgesChange: onEdgesChange,
                    onConnect: onConnect,
                    onInit: onInit,
                    onNodeDragStart: onNodeDragStart,
                    onNodeDrag: onNodeDrag,
                    onNodeDragStop: onNodeDragStop,
                    nodesDraggable: true,
                    nodesConnectable: true,
                    elementsSelectable: true,
                    panOnDrag: [1, 2], // Left or middle mouse button
                    selectionOnDrag: false,
                    zoomOnScroll: true,
                    zoomOnPinch: true,
                    zoomOnDoubleClick: true,
                    preventScrolling: true,
                    fitView: false,
                    attributionPosition: 'bottom-left',
                    defaultViewport: { x: 0, y: 0, zoom: 1 }
                });
            };

            // Wrap in ReactFlowProvider for proper functionality
            console.log('Creating wrapped component with provider...');
            
            let AppComponent;
            if (ReactFlowProvider) {
                // Wrap the flow component in provider
                AppComponent = React.createElement(ReactFlowProvider, {},
                    React.createElement(FlowApp)
                );
                console.log('Created component with ReactFlowProvider');
            } else {
                // Use without provider if not available
                AppComponent = React.createElement(FlowApp);
                console.log('Created component without provider');
            }
            
            // Render to DOM
            try {
                const root = ReactDOM.createRoot ? ReactDOM.createRoot(container) : null;
                if (root) {
                    root.render(AppComponent);
                } else {
                    ReactDOM.render(AppComponent, container);
                }
                console.log('Workflow rendered successfully with controlled state management');
            } catch (error) {
                console.error('Error rendering workflow:', error);
                container.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">Error rendering workflow: ${error.message}</div>`;
            }
        }

        function getNodeIcon(type, nodeData) {
            // Check if agent has routing tools - make it a decision node
            if (type === 'agent' && nodeData?.tools) {
                const routingTools = ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'];
                const hasRoutingTools = nodeData.tools.some(tool => routingTools.includes(tool));
                if (hasRoutingTools) {
                    return '🎯'; // Decision agent icon
                }
            }
            
            const icons = {
                'tool': '🔧',
                'agent': '🤖',
                'workflow_call': '📞',
                'decision': '🎯'
            };
            return icons[type] || '⚙️';
        }
        
        function getCustomBorderRadius(nodeType, nodeData) {
            // Different border radius for different node types
            if (nodeType === 'decision' || (nodeType === 'agent' && nodeData?.tools?.some(t => ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'].includes(t)))) {
                return '8px'; // Rounded corners for decision nodes
            } else if (nodeType === 'tool') {
                return '4px'; // Slightly rounded for tool nodes
            } else {
                return '12px'; // More rounded for regular agent nodes
            }
        }
        
        function getNodeMinWidth(nodeType, nodeData) {
            // Different minimum widths for different node types
            if (nodeType === 'decision' || (nodeType === 'agent' && nodeData?.tools?.some(t => ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'].includes(t)))) {
                return '180px'; // Wider for decision nodes with more content
            } else if (nodeType === 'tool') {
                return '120px'; // Narrower for tool nodes
            } else {
                return '150px'; // Standard width for regular agents
            }
        }
        
        function getNodeMinHeight(nodeType, nodeData) {
            // Different minimum heights for different node types
            if (nodeType === 'decision' || (nodeType === 'agent' && nodeData?.tools?.some(t => ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'].includes(t)))) {
                return '80px'; // Taller for decision nodes with SLA info
            } else if (nodeType === 'tool') {
                return '60px'; // Shorter for tool nodes
            } else {
                return '70px'; // Standard height for regular agents
            }
        }
        
        function getNodeShadow(nodeType, nodeData) {
            // Different shadows for different node types
            if (nodeType === 'decision' || (nodeType === 'agent' && nodeData?.tools?.some(t => ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'].includes(t)))) {
                return '0 4px 12px rgba(255, 165, 0, 0.3), 0 2px 6px rgba(0, 0, 0, 0.2)'; // Orange glow for decision nodes
            } else if (nodeType === 'tool') {
                return '0 2px 8px rgba(100, 255, 100, 0.2), 0 1px 3px rgba(0, 0, 0, 0.1)'; // Subtle green glow for tools
            } else {
                return '0 3px 10px rgba(100, 255, 100, 0.25), 0 1px 4px rgba(0, 0, 0, 0.15)'; // Standard green glow for agents
            }
        }
        
        function getNodeTransform(nodeType, nodeData) {
            // Different transforms for different node types
            if (nodeType === 'decision' || (nodeType === 'agent' && nodeData?.tools?.some(t => ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'].includes(t)))) {
                return 'scale(1.0)'; // No scaling for decision nodes to maintain readability
            } else if (nodeType === 'tool') {
                return 'scale(0.95)'; // Slightly smaller for tool nodes
            } else {
                return 'scale(1.0)'; // Standard scale for regular agents
            }
        }
        
        function getNodeClipPath(nodeType, nodeData) {
            // Different clip paths for different node types
            if (nodeType === 'decision' || (nodeType === 'agent' && nodeData?.tools?.some(t => ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'].includes(t)))) {
                return 'polygon(0 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 8px 100%, 0 calc(100% - 8px))'; // Slightly angled corners for decision nodes
            } else if (nodeType === 'tool') {
                return 'none'; // No clip path for tool nodes
            } else {
                return 'none'; // No clip path for regular agents
            }
        }
        
        function getNodeBackgroundPattern(nodeType, nodeData) {
            // Different background patterns for different node types
            if (nodeType === 'decision' || (nodeType === 'agent' && nodeData?.tools?.some(t => ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'].includes(t)))) {
                // Subtle diagonal lines pattern for decision nodes
                return 'linear-gradient(45deg, rgba(255, 165, 0, 0.05) 25%, transparent 25%, transparent 75%, rgba(255, 165, 0, 0.05) 75%), linear-gradient(-45deg, rgba(255, 165, 0, 0.05) 25%, transparent 25%, transparent 75%, rgba(255, 165, 0, 0.05) 75%)';
            } else if (nodeType === 'tool') {
                // Subtle dot pattern for tool nodes  
                return 'radial-gradient(circle at 2px 2px, rgba(100, 255, 100, 0.1) 1px, transparent 1px)';
            } else {
                return 'none'; // No background pattern for regular agents
            }
        }
        
        function getSLAType(sla, tools) {
            // Classify SLA enforcement level based on requirements
            if (!sla || !sla.enforce_usage) return 'none';
            
            const routingTools = ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'];
            const hasRoutingTools = tools && tools.some(tool => routingTools.includes(tool));
            
            if (hasRoutingTools && sla.final_tool_must_be) {
                return 'decision';  // Decision agent with routing requirements
            } else if (sla.min_tool_calls > 2 || (sla.required_tools && sla.required_tools.length > 2)) {
                return 'strict';    // High tool usage requirements  
            } else if (sla.tool_usage_required || (sla.required_tools && sla.required_tools.length > 0)) {
                return 'enforced'; // Basic tool enforcement
            }
            
            return 'none';
        }
        
        function getSLALabel(slaType) {
            switch (slaType) {
                case 'decision':
                    return 'DECISION';
                case 'strict':
                    return 'STRICT';
                case 'enforced':
                    return 'ENFORCED';
                default:
                    return '';
            }
        }
        
        function generateSLAPills(sla, tools) {
            const pills = [];
            const routingTools = ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'];
            const hasRoutingTools = tools && tools.some(tool => routingTools.includes(tool));
            
            // Main SLA enforcement pill with detailed tooltip
            if (sla.enforce_usage) {
                const slaType = getSLAType(sla, tools);
                const colors = {
                    'decision': { bg: 'rgba(255, 165, 0, 0.25)', border: '#ffa500', text: '#ffa500' },
                    'strict': { bg: 'rgba(255, 50, 50, 0.25)', border: '#ff3232', text: '#ff3232' },
                    'enforced': { bg: 'rgba(255, 200, 0, 0.25)', border: '#ffc800', text: '#ffc800' }
                };
                const color = colors[slaType] || colors.enforced;
                
                // Build detailed SLA info for tooltip
                const slaDetails = [];
                if (sla.tool_usage_required) slaDetails.push('• Tool usage REQUIRED');
                if (sla.required_tools && sla.required_tools.length > 0) {
                    slaDetails.push(`• Required tools: ${sla.required_tools.join(', ')}`);
                }
                if (sla.final_tool_must_be) {
                    slaDetails.push(`• Final tool MUST be: ${sla.final_tool_must_be}`);
                }
                if (sla.min_tool_calls > 0) {
                    slaDetails.push(`• Minimum ${sla.min_tool_calls} tool calls`);
                }
                if (sla.timeout_seconds && sla.timeout_seconds !== 120) {
                    slaDetails.push(`• Timeout: ${sla.timeout_seconds}s`);
                }
                if (sla.max_retries && sla.max_retries !== 2) {
                    slaDetails.push(`• Max retries: ${sla.max_retries}`);
                }
                
                const tooltipText = `SLA ENFORCEMENT DETAILS:\\n${slaDetails.join('\\n')}`;
                
                pills.push(`
                    <div class="sla-pill main-sla" style="
                        background: ${color.bg};
                        border: 1px solid ${color.border};
                        color: ${color.text};
                        padding: 2px 6px;
                        border-radius: 8px;
                        font-size: 9px;
                        font-weight: bold;
                        display: flex;
                        align-items: center;
                        gap: 2px;
                        cursor: help;
                    " title="${tooltipText}">
                        <span>🎯</span>
                        <span>${getSLALabel(slaType)}</span>
                        <span style="opacity: 0.7; font-size: 8px;">ⓘ</span>
                    </div>
                `);
            }
            
            // Required tools pills with enhanced labeling
            if (sla.required_tools && sla.required_tools.length > 0) {
                // Add a label pill first
                pills.push(`
                    <div class="sla-pill tool-label" style="
                        background: rgba(70, 70, 70, 0.3);
                        border: 1px solid #666;
                        color: #ccc;
                        padding: 1px 3px;
                        border-radius: 4px;
                        font-size: 7px;
                        font-weight: 600;
                        text-transform: uppercase;
                    ">
                        REQUIRED
                    </div>
                `);
                
                sla.required_tools.forEach(tool => {
                    const isRoutingTool = routingTools.includes(tool);
                    const toolColor = isRoutingTool 
                        ? { bg: 'rgba(255, 140, 0, 0.2)', border: '#ff8c00', text: '#ff8c00' }
                        : { bg: 'rgba(100, 255, 100, 0.2)', border: '#64ff64', text: '#64ff64' };
                    
                    pills.push(`
                        <div class="sla-pill tool-required" style="
                            background: ${toolColor.bg};
                            border: 1px solid ${toolColor.border};
                            color: ${toolColor.text};
                            padding: 1px 4px;
                            border-radius: 6px;
                            font-size: 8px;
                            font-weight: 500;
                            display: flex;
                            align-items: center;
                            gap: 1px;
                        " title="This tool MUST be used during execution">
                            <span>${isRoutingTool ? '🎯' : '🔧'}</span>
                            <span>${tool}</span>
                        </div>
                    `);
                });
            }
            
            // Final tool requirement - CRITICAL for routing decisions
            if (sla.final_tool_must_be) {
                // Add label first
                pills.push(`
                    <div class="sla-pill final-label" style="
                        background: rgba(138, 43, 226, 0.4);
                        border: 1px solid #8a2be2;
                        color: #ffffff;
                        padding: 1px 3px;
                        border-radius: 4px;
                        font-size: 7px;
                        font-weight: 700;
                        text-transform: uppercase;
                    ">
                        FINAL
                    </div>
                `);
                
                const isRoutingTool = routingTools.includes(sla.final_tool_must_be);
                pills.push(`
                    <div class="sla-pill final-tool" style="
                        background: rgba(138, 43, 226, 0.25);
                        border: 2px solid #8a2be2;
                        color: #8a2be2;
                        padding: 2px 5px;
                        border-radius: 6px;
                        font-size: 8px;
                        font-weight: 700;
                        display: flex;
                        align-items: center;
                        gap: 2px;
                        border-style: double;
                    " title="This tool MUST be called LAST - critical for routing decisions!">
                        <span>🏁</span>
                        <span>${sla.final_tool_must_be}</span>
                        <span style="opacity: 0.8;">LAST</span>
                    </div>
                `);
            }
            
            // Minimum tool calls requirement
            if (sla.min_tool_calls > 0) {
                pills.push(`
                    <div class="sla-pill min-calls" style="
                        background: rgba(255, 193, 7, 0.2);
                        border: 1px solid #ffc107;
                        color: #ffc107;
                        padding: 1px 4px;
                        border-radius: 6px;
                        font-size: 8px;
                        font-weight: 500;
                        display: flex;
                        align-items: center;
                        gap: 1px;
                    ">
                        <span>📊</span>
                        <span>≥${sla.min_tool_calls}</span>
                    </div>
                `);
            }
            
            // Timeout information (if non-default)
            if (sla.timeout_seconds && sla.timeout_seconds !== 120) {
                pills.push(`
                    <div class="sla-pill timeout" style="
                        background: rgba(108, 117, 125, 0.2);
                        border: 1px solid #6c757d;
                        color: #6c757d;
                        padding: 1px 4px;
                        border-radius: 6px;
                        font-size: 8px;
                        font-weight: 500;
                        display: flex;
                        align-items: center;
                        gap: 1px;
                    ">
                        <span>⏱️</span>
                        <span>${sla.timeout_seconds}s</span>
                    </div>
                `);
            }
            
            return pills;
        }

        function getNodeColor(type, nodeData) {
            // Check if it's a decision-type agent based on tools
            if (type === 'agent' && nodeData?.tools) {
                const routingTools = ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'];
                const hasRoutingTools = nodeData.tools.some(tool => routingTools.includes(tool));
                if (hasRoutingTools) {
                    // Decision agent - orange/amber gradient
                    return 'linear-gradient(135deg, rgba(255, 140, 0, 0.3), rgba(255, 165, 0, 0.2))';
                }
            }
            
            const colors = {
                'tool': 'linear-gradient(135deg, rgba(100, 255, 100, 0.15), rgba(76, 175, 80, 0.12))',
                'agent': 'linear-gradient(135deg, rgba(255, 130, 40, 0.15), rgba(30, 144, 255, 0.12))',
                'workflow_call': 'linear-gradient(135deg, rgba(148, 0, 211, 0.15), rgba(138, 43, 226, 0.12))',
                'decision': 'linear-gradient(135deg, rgba(255, 140, 0, 0.3), rgba(255, 165, 0, 0.2))'
            };
            return colors[type] || 'linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(200, 200, 200, 0.08))';
        }
        
        function getNodeShape(type, nodeData) {
            // Check if it's a decision-type agent
            if (type === 'agent' && nodeData?.tools) {
                const routingTools = ['conditional_gate', 'threshold_gate', 'conditional_multi_gate'];
                const hasRoutingTools = nodeData.tools.some(tool => routingTools.includes(tool));
                if (hasRoutingTools) {
                    return 'diamond'; // Diamond shape for decision agents
                }
            }
            
            const shapes = {
                'tool': 'hexagon',      // Hexagonal for tools
                'agent': 'circle',      // Circular for regular agents
                'workflow_call': 'rectangle', // Rectangle for workflow calls
                'decision': 'diamond'   // Diamond for decision nodes
            };
            return shapes[type] || 'rectangle';
        }
        
        function getExecutionModeIndicator(nodeData) {
            if (!nodeData?.execution_mode) return '';
            
            const mode = nodeData.execution_mode;
            if (mode === 'for_each') {
                return '<div class="execution-mode-indicator for-each" title="For Each: Runs separately for each dependency">🔄</div>';
            } else if (mode === 'consolidate') {
                return '<div class="execution-mode-indicator consolidate" title="Consolidate: Waits for ALL dependencies">⚡</div>';
            }
            return '';
        }

        // Utility functions
        function fitView() {
            if (reactFlowInstance) {
                console.log('Fitting view with instance:', reactFlowInstance);
                reactFlowInstance.fitView({ padding: 0.2, duration: 800 });
            } else {
                console.log('ReactFlow instance not available yet');
            }
        }

        function downloadWorkflow() {
            if (!currentWorkflow) return;
            
            const dataStr = JSON.stringify(currentWorkflow, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `${currentWorkflow.title.replace(/\s+/g, '_')}.json`;
            link.click();
        }

        // Example workflows functions
        async function loadExamples() {
            try {
                const response = await fetch('/api/workflows/combined');
                const data = await response.json();
                
                const exampleSelect = document.getElementById('exampleSelect');
                const savedSelect = document.getElementById('savedWorkflowSelect');
                
                // Clear existing options except the first one
                exampleSelect.innerHTML = '<option value="">📋 Select Example...</option>';
                savedSelect.innerHTML = '<option value="">💾 Select Saved...</option>';
                
                // Add example options to examples dropdown
                Object.entries(data.examples).forEach(([key, example]) => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = `📋 ${example.title} (${example.node_count} nodes)`;
                    option.title = example.description;
                    option.dataset.source = 'example';
                    exampleSelect.appendChild(option);
                });
                
                // Add saved workflows grouped by lineage
                if (data.lineage_groups && Object.keys(data.lineage_groups).length > 0) {
                    Object.values(data.lineage_groups).forEach(group => {
                        // Add group header (not selectable)
                        const groupHeader = document.createElement('option');
                        groupHeader.disabled = true;
                        groupHeader.textContent = `📁 ${group.title} (${group.total_revisions} revisions)`;
                        groupHeader.style.fontWeight = 'bold';
                        groupHeader.style.backgroundColor = '#f0f0f0';
                        savedSelect.appendChild(groupHeader);
                        
                        // Add individual revisions
                        group.revisions.forEach(revision => {
                            const option = document.createElement('option');
                            option.value = revision.id;
                            const isLatest = revision.rev === group.latest_rev ? ' ← Current' : '';
                            option.textContent = `  ├── Rev ${revision.rev} (${revision.node_count} nodes)${isLatest}`;
                            option.title = revision.description;
                            option.dataset.source = 'saved';
                            option.dataset.baseId = group.base_id;
                            option.dataset.rev = revision.rev;
                            savedSelect.appendChild(option);
                        });
                    });
                } else {
                    // Fallback to individual workflows if no lineage groups
                    Object.entries(data.saved).forEach(([key, workflow]) => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = `💾 ${workflow.title} (${workflow.node_count} nodes)`;
                        option.title = workflow.description;
                        option.dataset.source = 'saved';
                        savedSelect.appendChild(option);
                    });
                }
                
                console.log('✅ Loaded examples:', {
                    examples: Object.keys(data.examples).length,
                    saved: Object.keys(data.saved).length
                });
            } catch (error) {
                console.error('❌ Error loading examples:', error);
            }
        }
        
        async function loadSelectedExample() {
            const selectElement = document.getElementById('exampleSelect');
            const selectedValue = selectElement.value;
            
            if (!selectedValue) {
                return; // No selection made
            }
            
            try {
                setLoading(true);
                console.log('📋 Loading workflow:', selectedValue);
                
                const isExample = selectElement.options[selectElement.selectedIndex].dataset.source === 'example';
                
                let response;
                if (isExample) {
                    response = await fetch(`/api/example/${selectedValue}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                } else {
                    response = await fetch(`/api/workflows/load/${selectedValue}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('📦 Received workflow data:', data);
                
                if (data.workflow) {
                    console.log('🔄 Updating workflow with data');
                    
                    // Use the same function that handles AI-generated workflows
                    handleWorkflowUpdate(data.workflow);
                    
                    // Reset dropdown to placeholder
                    selectElement.value = '';
                    
                    console.log('✅ Workflow loaded:', data.workflow.title);
                } else {
                    console.error('❌ No workflow in response:', data);
                    alert('Failed to load workflow: No workflow data received');
                }
            } catch (error) {
                console.error('❌ Error loading workflow:', error);
                alert('Failed to load workflow: ' + error.message);
            } finally {
                setLoading(false);
            }
        }

        async function loadSelectedSavedWorkflow() {
            const selectElement = document.getElementById('savedWorkflowSelect');
            const selectedValue = selectElement.value;
            
            if (!selectedValue) {
                return; // No selection made
            }
            
            try {
                setLoading(true);
                console.log('💾 Loading saved workflow:', selectedValue);
                
                const response = await fetch(`/api/workflows/load/${selectedValue}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('📦 Received saved workflow data:', data);
                
                if (data.workflow) {
                    console.log('🔄 Updating workflow with saved data');
                    
                    // Use the same function that handles AI-generated workflows
                    handleWorkflowUpdate(data.workflow);
                    
                    // Reset dropdown to placeholder
                    selectElement.value = '';
                    
                    console.log('✅ Saved workflow loaded:', data.workflow.title);
                    addMessageToChat(`💾 Loaded saved workflow: "${data.workflow.title}"`, 'assistant');
                } else {
                    console.error('❌ No workflow in response:', data);
                    alert('Failed to load saved workflow: No workflow data received');
                }
            } catch (error) {
                console.error('❌ Error loading saved workflow:', error);
                alert('Failed to load saved workflow: ' + error.message);
            } finally {
                setLoading(false);
            }
        }
        
        // Delete workflow functionality removed - can be added to a separate UI later
        
        async function saveCurrentWorkflow() {
            if (!currentWorkflow) {
                alert('No workflow to save');
                return;
            }
            
            const name = prompt('Enter a name for this workflow:', currentWorkflow.title || 'My Workflow');
            if (!name) return;
            
            const description = prompt('Enter a description (optional):', currentWorkflow.description || '');
            const tagsInput = prompt('Enter tags (comma-separated, optional):', '');
            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];
            
            try {
                setLoading(true);
                
                const response = await fetch('/api/workflows/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, description, tags })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('✅ Workflow saved:', data.workflow_id);
                    alert(`Workflow "${name}" saved successfully!`);
                    await loadExamples(); // Refresh the list
                } else {
                    throw new Error(data.error || 'Save failed');
                }
            } catch (error) {
                console.error('❌ Error saving workflow:', error);
                alert('Failed to save workflow: ' + error.message);
            } finally {
                setLoading(false);
            }
        }
        
        async function exportCurrentWorkflowYAML() {
            if (!currentWorkflow) {
                alert('No workflow to export');
                return;
            }
            
            try {
                // Generate YAML from current workflow
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        query: 'export current workflow as yaml',
                        refine: false 
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to generate YAML export');
                }
                
                // For now, just download the workflow as JSON
                // TODO: Add proper YAML export endpoint
                const workflowName = currentWorkflow.title?.replace(/[^a-z0-9]/gi, '_') || 'workflow';
                const dataStr = JSON.stringify(currentWorkflow, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `${workflowName}.json`;
                link.click();
                
                console.log('✅ Workflow exported');
            } catch (error) {
                console.error('❌ Error exporting workflow:', error);
                alert('Failed to export workflow: ' + error.message);
            }
        }

        // Event listeners
        function initializeEventListeners() {
            // Workflow controls (Note: dropdown selects removed in favor of search interface)
            const clearBtn = document.getElementById('clearBtn');
            const executeBtn = document.getElementById('executeBtn');
            const runWithInputsBtn = document.getElementById('runWithInputsBtn');
            const stopBtn = document.getElementById('stopBtn');
            const saveBtn = document.getElementById('saveBtn');
            const exportBtn = document.getElementById('exportBtn');
            
            if (clearBtn) {
                clearBtn.addEventListener('click', clearWorkflow);
            }
            
            if (executeBtn) {
                executeBtn.addEventListener('click', executeWorkflow);
            }
            
            if (runWithInputsBtn) {
                runWithInputsBtn.addEventListener('click', triggerWorkflowForInputs);
            }
            
            if (stopBtn) {
                stopBtn.addEventListener('click', stopExecution);
            }
            
            if (saveBtn) {
                saveBtn.addEventListener('click', saveCurrentWorkflow);
            }
            
            if (exportBtn) {
                exportBtn.addEventListener('click', exportCurrentWorkflowYAML);
            }
        }

        // Debug function to check loaded libraries
        function debugLibraries() {
            console.log('=== Library Debug ===');
            console.log('React:', typeof React);
            console.log('ReactDOM:', typeof ReactDOM);
            console.log('ReactFlow:', typeof ReactFlow);
            console.log('window.ReactFlow:', typeof window.ReactFlow);
            if (typeof ReactFlow !== 'undefined') {
                console.log('ReactFlow keys:', Object.keys(ReactFlow));
                console.log('ReactFlow.default:', typeof ReactFlow.default);
                console.log('ReactFlow.ReactFlow:', typeof ReactFlow.ReactFlow);
                console.log('applyNodeChanges:', typeof ReactFlow.applyNodeChanges);
                console.log('applyEdgeChanges:', typeof ReactFlow.applyEdgeChanges);
            }
            console.log('==================');
        }

        // Initialize
        // Chat Interface Functions
        function initializeChatInterface() {
            const chatInput = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendBtn');
            const clearChatBtn = document.getElementById('clearChatBtn');
            
            // Send on button click
            sendBtn.addEventListener('click', sendChatMessage);
            
            // Send on Enter (but not Shift+Enter)
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendChatMessage();
                }
            });
            
            // Clear chat
            clearChatBtn.addEventListener('click', () => {
                document.getElementById('chatMessages').innerHTML = `
                    <div class="message assistant">
                        <div class="message-bubble">
                            👋 Hello! I'm your workflow design assistant. Tell me what kind of workflow you'd like to create and I'll help you build it!
                        </div>
                        <div class="message-time">Just now</div>
                    </div>
                `;
                clearWorkflow();
            });
        }
        
        async function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (!message) return;
            
            // Add user message to chat
            addMessageToChat(message, 'user');
            
            // Clear input
            chatInput.value = '';
            
            // Generate workflow based on message
            try {
                setLoading(true);
                const data = await apiCall('/generate', {
                    method: 'POST',
                    body: JSON.stringify({ 
                        query: message,
                        refine: currentWorkflow !== null
                    })
                });
                
                console.log('📦 API Response:', {
                    success: data.success,
                    has_workflow: !!data.workflow,
                    has_agent_response: !!data.agent_response,
                    agent_response_length: data.agent_response ? data.agent_response.length : 0,
                    full_data: data
                });
                
                if (data.success) {
                    // Check if this is a chat-only response (no workflow)
                    if (data.agent_response && !data.workflow) {
                        console.log('💬 Chat-only response detected in frontend');
                        // Chat-only response - don't update workflow, just show message
                        addMessageToChat(data.agent_response, 'assistant');
                        return; // IMPORTANT: Exit early for chat-only responses
                    } else if (data.workflow) {
                        console.log('🔧 Normal workflow response detected');
                        // Normal workflow response
                        handleWorkflowUpdate(data.workflow);
                        // Wait for handleWorkflowUpdate to complete before accessing currentWorkflow
                        // Use agent_response if available, otherwise use workflow reasoning or default message
                        console.log('🔍 Debug response data:', {
                            agent_response: data.agent_response,
                            workflow_reasoning: data.workflow?.reasoning,
                            agent_response_length: data.agent_response?.length,
                            workflow_reasoning_length: data.workflow?.reasoning?.length
                        });
                        
                        const response = data.agent_response || 
                            (data.workflow && data.workflow.reasoning) || 
                            `✨ I've ${data.workflow && data.workflow.rev > 1 ? 'refined' : 'created'} your workflow "${data.workflow ? data.workflow.title : 'unnamed'}". It has ${data.workflow ? data.workflow.nodes.length : 0} nodes and ${data.workflow ? data.workflow.edges.length : 0} edges.`;
                        addMessageToChat(response, 'assistant');
                    } else {
                        console.log('⚠️ Success but no workflow or agent_response', data);
                        // Try to extract any useful information from the response
                        const fallbackMessage = data.chat_response || 
                                               data.message || 
                                               data.response ||
                                               (data.reasoning ? `🤔 ${data.reasoning}` : null) ||
                                               '✨ Request processed - the system may have provided a chat-only response. Check the console for details.';
                        addMessageToChat(fallbackMessage, 'assistant');
                    }
                } else {
                    addMessageToChat('❌ Error: ' + data.error, 'assistant');
                }
            } catch (error) {
                console.error('❌ Full error object:', error);
                console.error('❌ Error stack:', error.stack);
                addMessageToChat('❌ Failed to generate workflow: ' + error.message, 'assistant');
            } finally {
                setLoading(false);
            }
        }
        
        function addMessageToChat(message, sender, options = {}) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const now = new Date();
            const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            // Simple markdown to HTML converter
            let formattedMessage = message;
            
            // Preserve special formatting for execution reports
            if (options.isExecutionReport || message.includes('SYSTEM EXECUTION REPORT')) {
                // Keep line breaks and spacing for execution reports
                formattedMessage = formattedMessage
                    .replace(/═+/g, '<hr style="border: 1px solid rgba(100, 255, 100, 0.3); margin: 0.5rem 0;">')
                    .replace(/─+/g, '<hr style="border: 1px dashed rgba(100, 255, 100, 0.2); margin: 0.3rem 0;">');
            }
            
            // Headers
            formattedMessage = formattedMessage.replace(/^### (.*?)$/gm, '<h4>$1</h4>');
            formattedMessage = formattedMessage.replace(/^## (.*?)$/gm, '<h3>$1</h3>');
            formattedMessage = formattedMessage.replace(/^# (.*?)$/gm, '<h2>$1</h2>');
            
            // Bold and italic
            formattedMessage = formattedMessage.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
            formattedMessage = formattedMessage.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            formattedMessage = formattedMessage.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Code blocks and inline code
            formattedMessage = formattedMessage.replace(/```(.*?)```/gs, '<pre><code>$1</code></pre>');
            formattedMessage = formattedMessage.replace(/`(.*?)`/g, '<code>$1</code>');
            
            // Lists
            formattedMessage = formattedMessage.replace(/^\* (.*?)$/gm, '<li>$1</li>');
            formattedMessage = formattedMessage.replace(/^- (.*?)$/gm, '<li>$1</li>');
            formattedMessage = formattedMessage.replace(/^• (.*?)$/gm, '<li>$1</li>');
            formattedMessage = formattedMessage.replace(/(<li>.*<\/li>\n?)+/gs, function(match) {
                return '<ul>' + match + '</ul>';
            });
            
            // Numbered lists
            formattedMessage = formattedMessage.replace(/^\d+\. (.*?)$/gm, '<li class="numbered">$1</li>');
            formattedMessage = formattedMessage.replace(/(<li class="numbered">.*<\/li>\n?)+/gs, function(match) {
                return '<ol>' + match.replace(/class="numbered"/g, '') + '</ol>';
            });
            
            // Line breaks - preserve formatting for execution reports
            if (options.isExecutionReport || sender === 'system') {
                formattedMessage = formattedMessage.replace(/\n/g, '<br>');
            } else {
                formattedMessage = formattedMessage.replace(/\n\n/g, '</p><p>');
                formattedMessage = formattedMessage.replace(/\n/g, '<br>');
                formattedMessage = '<p>' + formattedMessage + '</p>';
                
                // Clean up empty paragraphs
                formattedMessage = formattedMessage.replace(/<p><\/p>/g, '');
                formattedMessage = formattedMessage.replace(/<p>(<h[1-6]>)/g, '$1');
                formattedMessage = formattedMessage.replace(/(<\/h[1-6]>)<\/p>/g, '$1');
                formattedMessage = formattedMessage.replace(/<p>(<ul>|<ol>)/g, '$1');
                formattedMessage = formattedMessage.replace(/(<\/ul>|<\/ol>)<\/p>/g, '$1');
            }
            
            // Check if message is long and should be collapsible
            const messageLength = message.length;
            const isLongMessage = messageLength > 500 || message.split('\n').length > 15;
            
            if (isLongMessage && (options.isExecutionReport || sender === 'system')) {
                // Create collapsible execution report
                const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                const previewLines = message.split('\n').slice(0, 10).join('\n');
                
                // Apply markdown formatting to preview as well
                let previewFormatted = previewLines;
                
                // Preserve special formatting for execution reports
                if (options.isExecutionReport || previewLines.includes('SYSTEM EXECUTION REPORT')) {
                    previewFormatted = previewFormatted
                        .replace(/═+/g, '<hr style="border: 1px solid rgba(100, 255, 100, 0.3); margin: 0.5rem 0;">')
                        .replace(/─+/g, '<hr style="border: 1px dashed rgba(100, 255, 100, 0.2); margin: 0.3rem 0;">');
                }
                
                // Apply same markdown processing as full message
                previewFormatted = previewFormatted.replace(/^### (.*?)$/gm, '<h4>$1</h4>');
                previewFormatted = previewFormatted.replace(/^## (.*?)$/gm, '<h3>$1</h3>');
                previewFormatted = previewFormatted.replace(/^# (.*?)$/gm, '<h2>$1</h2>');
                previewFormatted = previewFormatted.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
                previewFormatted = previewFormatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                previewFormatted = previewFormatted.replace(/\*(.*?)\*/g, '<em>$1</em>');
                previewFormatted = previewFormatted.replace(/`(.*?)`/g, '<code>$1</code>');
                previewFormatted = previewFormatted.replace(/\n/g, '<br>');
                
                messageDiv.innerHTML = `
                    <div class="message-bubble collapsible-message" id="${messageId}">
                        <div class="message-preview" onclick="toggleMessage('${messageId}')">
                            ${previewFormatted}<br>
                            <span style="color: rgba(100, 255, 100, 0.7); cursor: pointer; font-size: 0.9em;">
                                ▼ Click to expand full report (${message.split('\n').length} lines)
                            </span>
                        </div>
                        <div class="message-full" style="display: none;">
                            ${formattedMessage}
                            <br>
                            <span style="color: rgba(100, 255, 100, 0.7); cursor: pointer; font-size: 0.9em;" 
                                  onclick="toggleMessage('${messageId}')">
                                ▲ Click to collapse
                            </span>
                        </div>
                    </div>
                    <div class="message-time">${timeStr}</div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="message-bubble">${formattedMessage}</div>
                    <div class="message-time">${timeStr}</div>
                `;
            }
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function toggleMessage(messageId) {
            const messageEl = document.getElementById(messageId);
            if (!messageEl) return;
            
            const preview = messageEl.querySelector('.message-preview');
            const full = messageEl.querySelector('.message-full');
            
            if (preview && full) {
                if (preview.style.display === 'none') {
                    preview.style.display = 'block';
                    full.style.display = 'none';
                } else {
                    preview.style.display = 'none';
                    full.style.display = 'block';
                }
            }
        }
        
        // Unified Search Functions
        let currentSearchTab = 'tools';
        let searchTimeout;
        
        function initializeToolSearch() {
            const searchInput = document.getElementById('unifiedSearchInput');
            const searchResults = document.getElementById('searchResults');
            
            if (!searchInput || !searchResults) {
                console.error('Search elements not found');
                return;
            }
            
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.trim();
                
                if (query.length < 2) {
                    searchResults.style.display = 'none';
                    return;
                }
                
                // Debounce search requests
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    performTabSearch(query, currentSearchTab, searchResults);
                }, API_CONFIG.SEARCH_DEBOUNCE_MS);
            });
        }
        
        function switchSearchTab(tab) {
            currentSearchTab = tab;
            
            // Update tab styling
            const toolsTab = document.getElementById('toolsTab');
            const workflowsTab = document.getElementById('workflowsTab');
            const analyticsTab = document.getElementById('analyticsTab');
            const searchInput = document.getElementById('unifiedSearchInput');
            
            // Reset all tabs
            [toolsTab, workflowsTab, analyticsTab].forEach(tabEl => {
                tabEl.classList.remove('active');
                tabEl.style.background = 'transparent';
                tabEl.style.boxShadow = 'none';
                tabEl.style.color = 'rgba(100, 255, 100, 0.7)';
            });
            
            if (tab === 'tools') {
                toolsTab.classList.add('active');
                toolsTab.style.background = 'linear-gradient(135deg, rgba(255, 107, 53, 0.3), rgba(255, 107, 53, 0.1))';
                toolsTab.style.boxShadow = '0 2px 8px rgba(255, 107, 53, 0.2)';
                toolsTab.style.color = '#ff6b35';
                searchInput.placeholder = '🔍 Search tools...';
            } else if (tab === 'workflows') {
                workflowsTab.classList.add('active');
                workflowsTab.style.background = 'linear-gradient(135deg, rgba(100, 255, 100, 0.3), rgba(100, 255, 100, 0.1))';
                workflowsTab.style.boxShadow = '0 2px 8px rgba(100, 255, 100, 0.2)';
                workflowsTab.style.color = '#64ff64';
                searchInput.placeholder = '🔍 Search workflows...';
            } else if (tab === 'analytics') {
                analyticsTab.classList.add('active');
                analyticsTab.style.background = 'linear-gradient(135deg, rgba(138, 43, 226, 0.3), rgba(138, 43, 226, 0.1))';
                analyticsTab.style.boxShadow = '0 2px 8px rgba(138, 43, 226, 0.2)';
                analyticsTab.style.color = '#8a2be2';
                searchInput.placeholder = '🔍 Search tests and analytics...';
            }
            
            // Re-search with current query if there is one
            const query = searchInput.value.trim();
            if (query.length >= 2) {
                const searchResults = document.getElementById('searchResults');
                performTabSearch(query, tab, searchResults);
            }
        }
        
        async function performTabSearch(query, searchType, resultsContainer) {
            try {
                // Use separate endpoints for tools, workflows, and analytics
                let endpoint;
                if (searchType === 'tools') {
                    endpoint = '/search/tools';
                } else if (searchType === 'workflows') {
                    endpoint = '/search/workflows';
                } else if (searchType === 'analytics') {
                    endpoint = '/api/test-analytics/search';
                }
                
                const response = await fetch(`${API_CONFIG.SEARCH_SERVICE_URL}${endpoint}?query=${encodeURIComponent(query)}&limit=${API_CONFIG.SEARCH_MAX_RESULTS}`);
                const data = await response.json();
                
                if ((data.results && data.results.length > 0) || (searchType === 'analytics' && Array.isArray(data) && data.length > 0)) {
                    // Store results globally for easier access  
                    window.currentSearchResults = searchType === 'analytics' ? data : data.results;
                    
                    // Handle different result formats based on search type
                    if (searchType === 'analytics') {
                        // Analytics results use a different structure
                        resultsContainer.innerHTML = data.map((result, index) => {
                            const layerIcons = {
                                'logical': '📋',
                                'agentic': '🤖', 
                                'orchestration': '🎭',
                                'feedback': '💬'
                            };
                            const icon = layerIcons[result.test_layer] || '🧪';
                            const layerColor = {
                                'logical': '#64ff64',
                                'agentic': '#ff6b35',
                                'orchestration': '#8a2be2', 
                                'feedback': '#20b2aa'
                            }[result.test_layer] || '#888';
                            
                            const cleanDesc = result.test_description.replace(/[<>]/g, '').substring(0, 80);
                            const tagsDisplay = result.test_tags.slice(0, 3).join(', ');
                            
                            return `
                                <div class="search-result-item" onclick="selectAnalyticsResult('${result.test_id}', ${index})" 
                                     style="padding: 0.75rem; cursor: pointer; border-bottom: 1px solid rgba(138, 43, 226, 0.2); transition: all 0.2s ease; border-radius: 6px; margin: 0.25rem;"
                                     onmouseover="this.style.background='rgba(138, 43, 226, 0.1)'; this.style.transform='translateX(2px)'" 
                                     onmouseout="this.style.background='transparent'; this.style.transform='translateX(0)'">
                                    <div style="display: flex; align-items: flex-start; gap: 0.75rem;">
                                        <span style="font-size: 1.5em; opacity: 0.8;">${icon}</span>
                                        <div style="flex: 1; min-width: 0;">
                                            <div class="search-result-name" style="font-weight: 600; color: ${layerColor}; font-size: 0.9rem; margin-bottom: 0.25rem;">
                                                ${result.test_name}
                                            </div>
                                            <div class="search-result-desc" style="font-size: 0.75rem; color: #a0a0a0; line-height: 1.3; margin-bottom: 0.25rem;">
                                                ${cleanDesc}${cleanDesc.length >= 80 ? '...' : ''}
                                            </div>
                                            <div style="font-size: 0.65rem; color: #666;">
                                                ${result.test_layer} • ${result.test_category} • ${tagsDisplay}
                                            </div>
                                        </div>
                                        <div style="font-size: 0.65rem; color: #888; opacity: 0.7;">
                                            ${(result.relevance_score).toFixed(1)}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('');
                    } else {
                        // Tools and workflows use the original structure
                        resultsContainer.innerHTML = data.results.map((result, index) => {
                            const icon = result.result_type === 'tool' ? '🔧' : '🌊';
                            const typeColor = result.result_type === 'tool' ? '#ff6b35' : '#64ff64';
                            
                            // Clean and shorten description for display
                            const cleanDesc = result.description.replace(/[<>]/g, '').substring(0, 80);
                            
                            return `
                                <div class="search-result-item" onclick="selectSearchResult('${result.result_type}', '${result.title.replace(/'/g, "\\'")}', ${index})" 
                                     style="padding: 0.75rem; cursor: pointer; border-bottom: 1px solid rgba(255, 130, 40, 0.2); transition: all 0.2s ease; border-radius: 6px; margin: 0.25rem;"
                                     onmouseover="this.style.background='rgba(255, 130, 40, 0.1)'; this.style.transform='translateX(2px)'" 
                                     onmouseout="this.style.background='transparent'; this.style.transform='translateX(0)'">
                                    <div style="display: flex; align-items: flex-start; gap: 0.75rem;">
                                        <span style="font-size: 1.5em; opacity: 0.8;">${icon}</span>
                                        <div style="flex: 1; min-width: 0;">
                                            <div class="search-result-name" style="font-weight: 600; color: ${typeColor}; font-size: 0.9rem; margin-bottom: 0.25rem;">
                                                ${result.title}
                                            </div>
                                            <div class="search-result-desc" style="font-size: 0.75rem; color: #a0a0a0; line-height: 1.3; margin-bottom: 0.25rem;">
                                                ${cleanDesc}${cleanDesc.length >= 80 ? '...' : ''}
                                            </div>
                                            ${result.result_type === 'tool' && result.metadata?.parameter_count ? 
                                                `<div style="font-size: 0.65rem; color: #666;">
                                                    ${result.metadata.parameter_count} parameters • ${result.metadata.category}
                                                 </div>` : ''}
                                            ${result.result_type === 'workflow' && result.metadata?.node_count ? 
                                                `<div style="font-size: 0.65rem; color: #666;">
                                                    ${result.metadata.node_count} nodes • ${result.metadata.edge_count} edges
                                                 </div>` : ''}
                                        </div>
                                        <div style="font-size: 0.65rem; color: #888; opacity: 0.7;">
                                            ${(result.similarity_score * 100).toFixed(0)}%
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('');
                    }
                    resultsContainer.style.display = 'block';
                } else {
                    resultsContainer.innerHTML = `<div style="padding: 1rem; color: #666; text-align: center;">
                        <div style="font-size: 1.2em; margin-bottom: 0.5rem;">${searchType === 'tools' ? '🔧' : '🌊'}</div>
                        No ${searchType} found for "${query}"
                    </div>`;
                    resultsContainer.style.display = 'block';
                }
            } catch (error) {
                console.error('Search error:', error);
                resultsContainer.innerHTML = '<div style="padding: 0.5rem; color: #dc3545; text-align: center;">Search service unavailable</div>';
                resultsContainer.style.display = 'block';
            }
        }
        
        function selectSearchResult(type, title, resultIndex) {
            const searchInput = document.getElementById('unifiedSearchInput');
            const searchResults = document.getElementById('searchResults');
            
            if (type === 'tool') {
                // Handle tool selection - add to chat as context
                // Don't change the search input or hide results
                
                // Add to chat as context using available tools data or search result
                try {
                    const result = window.currentSearchResults[resultIndex];
                    if (result && availableTools[title]) {
                        addMessageToChat(`🔧 Selected tool: **${title}**\n\n${availableTools[title].description}`, 'assistant');
                    } else if (result) {
                        addMessageToChat(`🔧 Selected tool: **${title}**\n\n${result.description}`, 'assistant');
                    } else {
                        addMessageToChat(`🔧 Selected tool: ${title}`, 'assistant');
                    }
                } catch (e) {
                    addMessageToChat(`🔧 Selected tool: ${title}`, 'assistant');
                }
            } else if (type === 'workflow') {
                // Handle workflow selection - load the actual workflow
                // Don't change the search input or hide results
                
                try {
                    const result = window.currentSearchResults[resultIndex];
                    if (result && result.workflow_spec) {
                        console.log('Loading workflow from search:', result.workflow_spec);
                        
                        // Clear current execution state
                        currentExecution = null;
                        
                        // Set the current workflow - use the workflow_spec from search result
                        currentWorkflow = result.workflow_spec;
                        
                        // Use existing workflow rendering functions
                        updateWorkflowInfo(currentWorkflow);
                        renderWorkflow(currentWorkflow);
                        showWorkflowView();
                        updateButtons();
                        
                        // Add to chat to notify user
                        addMessageToChat(`🌊 Loaded workflow: **${title}**\n\n${result.description}`, 'assistant');
                        
                        // Optionally hide search results after successful load
                        setTimeout(() => {
                            searchResults.style.display = 'none';
                        }, 500);
                        
                    } else {
                        // Fallback - just add to chat
                        addMessageToChat(`🌊 Selected workflow example: ${title}`, 'assistant');
                    }
                } catch (e) {
                    console.error('Error loading workflow:', e);
                    addMessageToChat(`❌ Error loading workflow: ${title}`, 'assistant');
                }
            }
        }
        
        function selectAnalyticsResult(testId, resultIndex) {
            console.log('📊 Analytics result selected:', testId, resultIndex);
            
            try {
                const result = window.currentSearchResults[resultIndex];
                if (result) {
                    // Add test information to chat 
                    const testInfo = `📊 **Test Case**: ${result.test_name}
**Layer**: ${result.test_layer} | **Category**: ${result.test_category}
**Description**: ${result.test_description}
**Tags**: ${result.test_tags.join(', ')}
**Relevance Score**: ${result.relevance_score.toFixed(1)}

${result.snippet ? `**Matching Content**: ${result.snippet}` : ''}`;
                    
                    addMessageToChat(testInfo, 'assistant');
                } else {
                    addMessageToChat(`📊 Selected test case: ${testId}`, 'assistant');
                }
            } catch (e) {
                console.error('Error displaying analytics result:', e);
                addMessageToChat(`📊 Selected test case: ${testId}`, 'assistant');
            }
        }
        
        function selectTool(toolName) {
            const workflowToolSearch = document.getElementById('workflowToolSearch');
            const workflowToolResults = document.getElementById('workflowToolResults');
            
            if (workflowToolSearch && workflowToolResults) {
                workflowToolSearch.value = toolName;
                workflowToolResults.style.display = 'none';
                
                // Add to chat as context using available tools data
                const toolInfo = availableTools[toolName];
                if (toolInfo) {
                    addMessageToChat(`🔧 Selected tool: **${toolName}** - ${toolInfo.description}`, 'assistant');
                } else {
                    addMessageToChat(`🔧 Selected tool: ${toolName}`, 'assistant');
                }
            }
        }
        
        // Hide results when clicking outside  
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                const searchResults = document.getElementById('searchResults');
                if (searchResults) {
                    searchResults.style.display = 'none';
                }
            }
        });
        
        
        // User Input Form Functions
        let currentUserInputs = {};
        let pendingFormExecution = false;
        let nodeUserInputData = {}; // Store user input data for each node
        let cachedUserInputs = {}; // Cache user input values as they're entered
        
        function cacheUserInput(formId, value) {
            cachedUserInputs[formId] = value;
            console.log('💾 Cached user input:', formId, '=', value);
            console.log('💾 All cached inputs:', cachedUserInputs);
            
            // DEBUGGING: Log the exact keys being used
            console.log('🔍 DEBUG: Cache keys available:', Object.keys(cachedUserInputs));
            console.log('🔍 DEBUG: Cache key types:', Object.keys(cachedUserInputs).map(k => typeof k));
        }
        
        function cacheUserInputDual(primaryKey, secondaryKey, value) {
            // Cache with both keys to ensure backend can find it
            cachedUserInputs[primaryKey] = value;
            if (secondaryKey && secondaryKey !== primaryKey) {
                cachedUserInputs[secondaryKey] = value;
            }
            console.log('💾 Cached user input with dual keys:', primaryKey, '&', secondaryKey, '=', value);
            console.log('💾 All cached inputs:', cachedUserInputs);
            
            // DEBUGGING: Log the exact keys being used
            console.log('🔍 DEBUG: Primary key:', primaryKey, 'type:', typeof primaryKey);
            console.log('🔍 DEBUG: Secondary key:', secondaryKey, 'type:', typeof secondaryKey);
            console.log('🔍 DEBUG: Cache keys available:', Object.keys(cachedUserInputs));
        }
        
        function clearCachedInputs() {
            // Don't clear cache during active execution
            if (currentExecution && currentExecution.status === 'running') {
                console.log('⏸️ Not clearing cached inputs during active execution');
                return;
            }
            
            cachedUserInputs = {};
            console.log('🧹 Cleared all cached user inputs');
        }
        
        function submitAndRunWorkflow(formId) {
            console.log('📝 Submitting and running workflow for form:', formId);
            
            // Try to find the input field - could be enhanced textarea or regular input
            let inputField = document.getElementById(`enhanced-textarea-${formId}`);
            if (!inputField) {
                inputField = document.getElementById('user-input-field');
            }
            
            if (inputField) {
                // Cache the current value with the form ID as well for backup
                const formElement = inputField.closest('.user-input-form');
                const actualFormId = formElement ? formElement.id.replace('form-', '') : null;
                
                if (actualFormId && actualFormId !== formId) {
                    cacheUserInputDual(formId, actualFormId, inputField.value);
                } else {
                    cacheUserInput(formId, inputField.value);
                }
                
                // Don't hide the input form - let user see their input during execution
                // const userInputSection = document.getElementById('userInputSection');
                // if (userInputSection) {
                //     userInputSection.style.display = 'none';
                // }
                
                // Execute the workflow with cached inputs
                executeWorkflow();
            } else {
                alert('Please enter a value before submitting');
            }
        }

        function checkNodeForUserInput(node) {
            console.log('🔍 checkNodeForUserInput called for node:', node.id, node.type);
            console.log('🔍 Node data:', node.data);
            console.log('🔍 Node.data.source_name:', node.data.source_name);
            console.log('🔍 Node.data.tool_name (legacy):', node.data.tool_name);
            console.log('🔍 Node.data.tools:', node.data.tools);
            console.log('🔍 Node.data.config:', node.data.config);
            
            // Check if this node has a text input tool (user_input or prompt_tool)
            const hasTextInputTool = (
                (node.type === 'data_source' && (node.data.source_name === 'user_input' || node.data.source_name === 'prompt_tool')) ||
                (node.type === 'tool' && (node.data.tool_name === 'user_input' || node.data.tool_name === 'prompt_tool')) || // Backward compatibility
                (node.type === 'agent' && node.data.tools && node.data.tools.some(tool => tool.includes('user_input'))) ||
                (node.type === 'data_source' && node.data.config && node.data.config.prompt) // Also check if data_source has prompt config
            );
            
            if (hasTextInputTool) {
                console.log('✅ Node has text input tool! Creating input form from node config...');
                
                // For user_input tools, create the form immediately from the node config
                // Don't wait for execution results
                const nodeId = node.id;
                
                // Check if we have execution results first
                if (currentExecution && currentExecution.results && 
                    currentExecution.results.results) {
                    
                    console.log('🔍 Available result keys:', Object.keys(currentExecution.results.results));
                    
                    // Try to find the result by matching node type and tool
                    let nodeResult = null;
                    let foundKey = null;
                    
                    // First try exact node ID match
                    if (currentExecution.results.results[nodeId]) {
                        nodeResult = currentExecution.results.results[nodeId];
                        foundKey = nodeId;
                    } else {
                        // Look for user_input results in any node result
                        for (const [key, result] of Object.entries(currentExecution.results.results)) {
                            if (result && typeof result === 'object' && result.tool_type === 'user_input') {
                                nodeResult = result;
                                foundKey = key;
                                console.log('🔍 Found user_input result under key:', key);
                                break;
                            }
                        }
                    }
                    
                    if (nodeResult) {
                        console.log('✅ Using execution result for input form:', foundKey, nodeResult);
                        nodeUserInputData[nodeId] = nodeResult;
                        
                        return {
                            prompt: nodeResult.prompt || 'Enter your input:',
                            placeholder: nodeResult.placeholder || 'Type here...',
                            form_id: nodeResult.form_id || nodeId
                        };
                    }
                }
                
                // No execution results yet, create form from node config
                console.log('✅ Creating input form from node config:', node.data.config);
                const config = node.data.config || {};
                
                // Create form data from the node configuration
                const formData = {
                    prompt: config.prompt || 'Enter your input:',
                    placeholder: config.placeholder || 'Type here...',
                    form_id: nodeId,
                    input_type: config.input_type || 'textarea', // Default to textarea for better UX
                    tool_name: node.data.source_name || node.data.tool_name || 'user_input' // Add tool_name for enhanced UI
                };
                
                // Store this for later execution
                nodeUserInputData[nodeId] = formData;
                
                return formData;
                
            } else {
                console.log('🔍 Node does not have text input tool');
            }
            return false;
        }

        async function runWorkflowWithNodeInput(nodeId) {
            console.log('🚀 Running workflow with input from node:', nodeId);
            
            const inputElement = document.getElementById(`input-${nodeId}`);
            if (!inputElement) {
                alert('Input field not found');
                return;
            }
            
            const userValue = inputElement.value;
            if (!userValue || userValue.trim() === '') {
                alert('Please enter a value before running the workflow');
                return;
            }
            
            if (!currentWorkflow) {
                alert('No workflow available to execute');
                return;
            }
            
            console.log('✅ User input collected from node:', userValue);
            
            try {
                setExecutionLoading(true);
                
                // Execute workflow with user inputs - use nodeId as key instead of generic 'user_input'
                const data = await apiCall('/execute', {
                    method: 'POST',
                    body: JSON.stringify({ 
                        execute_current: true,
                        user_inputs: { [nodeId]: userValue },
                        form_id: nodeId
                    })
                });
                
                if (data.execution_id) {
                    currentExecution = {
                        id: data.execution_id,
                        status: 'running',
                        results: null,
                        start_time: new Date().toISOString()
                    };
                    executionTasks = {};
                    updateExecutionInfo();
                    startRuntimeUpdates();
                    
                    console.log('✅ Workflow execution started with user input:', userValue);
                } else {
                    throw new Error('No execution ID received');
                }
            } catch (error) {
                console.error('❌ Error executing workflow with input:', error);
                alert('Failed to execute workflow: ' + error.message);
            } finally {
                setExecutionLoading(false);
            }
        }

        function renderSimpleUserInputForm(inputData, taskKey = null) {
            console.log('📝 Rendering simple user input form:', inputData);
            console.log('📝 Task context:', taskKey);
            
            const userInputSection = document.getElementById('userInputSection');
            const userInputForm = document.getElementById('userInputForm');
            
            if (!userInputSection || !userInputForm) {
                console.error('❌ User input elements not found');
                return;
            }
            
            let formHTML = `
                <div class="user-input-form" id="form-${inputData.form_id}">
                    <h3>${inputData.prompt}</h3>
                    <div class="form-field">
            `;
            
            // Determine the cache key - prefer taskKey (node_id) if available, fallback to form_id
            const cacheKey = taskKey || inputData.form_id;
            console.log('📝 Using cache key:', cacheKey, '(taskKey:', taskKey, ', form_id:', inputData.form_id, ')');
            
            // Create the appropriate input based on type
            switch (inputData.input_type) {
                case 'textarea':
                    // Check if this is an enhanced text input tool
                    const toolName = inputData.tool_name || 'user_input'; // Default to user_input for backward compatibility
                    if (isTextInputTool(toolName)) {
                        // Use enhanced text input component with suggestions and collection data
                        formHTML += createEnhancedTextInput(
                            inputData.form_id, 
                            toolName, 
                            inputData, 
                            inputData.default_value || '',
                            inputData.suggestions || [],
                            inputData.collection_data || null
                        );
                        // Initialize character counts after DOM update
                        setTimeout(() => initializeCharacterCounts(), 50);
                    } else {
                        // Use regular textarea
                        formHTML += `<textarea 
                            id="user-input-field" 
                            name="${inputData.form_id}"
                            placeholder="${inputData.placeholder}"
                            style="width: 100%; min-height: 100px;"
                            oninput="cacheUserInputDual('${cacheKey}', '${inputData.form_id}', this.value)"
                            onchange="cacheUserInputDual('${cacheKey}', '${inputData.form_id}', this.value)"
                        >${inputData.default_value || ''}</textarea>`;
                    }
                    break;
                    
                case 'select':
                    formHTML += `<select id="user-input-field" name="${inputData.form_id}" style="width: 100%;" onchange="cacheUserInputDual('${cacheKey}', '${inputData.form_id}', this.value)">`;
                    if (inputData.options) {
                        inputData.options.forEach(option => {
                            const selected = option === inputData.default_value ? 'selected' : '';
                            formHTML += `<option value="${option}" ${selected}>${option}</option>`;
                        });
                    }
                    formHTML += '</select>';
                    break;
                    
                default: // text, number, etc.
                    formHTML += `<input 
                        type="${inputData.input_type}" 
                        id="user-input-field" 
                        name="${inputData.form_id}"
                        placeholder="${inputData.placeholder}"
                        value="${inputData.default_value || ''}"
                        style="width: 100%;"
                        oninput="cacheUserInputDual('${cacheKey}', '${inputData.form_id}', this.value)"
                        onchange="cacheUserInputDual('${cacheKey}', '${inputData.form_id}', this.value)"
                    />`;
                    break;
            }
            
            // Add submit button
            formHTML += `
                    </div>
                    <div class="form-submit-container">
                        <button type="button" class="form-submit-btn" onclick="submitAndRunWorkflow('${cacheKey}')">
                            Submit & Run Workflow
                        </button>
                    </div>
                </div>
            `;
            
            userInputForm.innerHTML = formHTML;
            userInputSection.style.display = 'block';
            
            // Focus on the input field
            setTimeout(() => {
                const inputField = document.getElementById('user-input-field');
                if (inputField) {
                    inputField.focus();
                }
            }, 100);
            
            // Scroll to show the form
            userInputSection.scrollIntoView({ behavior: 'smooth' });
            
            console.log('✅ Simple user input form rendered');
        }

        function collectFormInputs(formId) {
            const formElement = document.getElementById(`form-${formId}`);
            if (!formElement) {
                console.error('❌ Form not found:', formId);
                return null;
            }
            
            const inputs = {};
            const errors = {};
            let hasErrors = false;
            
            // Collect all form inputs
            const formFields = formElement.querySelectorAll('input, textarea, select');
            formFields.forEach(field => {
                const fieldName = field.name;
                if (!fieldName) return;
                
                let value = field.value;
                
                // Handle different input types
                if (field.type === 'checkbox') {
                    value = field.checked;
                } else if (field.type === 'number') {
                    value = field.value ? parseFloat(field.value) : '';
                }
                
                inputs[fieldName] = value;
                
                // Basic validation
                if (field.required && (!value || value === '')) {
                    errors[fieldName] = 'This field is required';
                    hasErrors = true;
                }
            });
            
            // Display validation errors
            Object.keys(errors).forEach(fieldName => {
                const errorElement = document.getElementById(`error-${fieldName}`);
                if (errorElement) {
                    errorElement.textContent = errors[fieldName];
                    errorElement.style.display = 'block';
                }
            });
            
            // Clear previous errors for valid fields
            Object.keys(inputs).forEach(fieldName => {
                if (!errors[fieldName]) {
                    const errorElement = document.getElementById(`error-${fieldName}`);
                    if (errorElement) {
                        errorElement.style.display = 'none';
                    }
                }
            });
            
            if (hasErrors) {
                console.log('❌ Form validation failed:', errors);
                return null;
            }
            
            console.log('✅ Form inputs collected:', inputs);
            return inputs;
        }

        async function executeWorkflowWithInputs(formId, inputs = null) {
            console.log('🚀 Executing workflow with user inputs for form:', formId);
            
            // If inputs weren't provided, try to collect them from the form
            if (!inputs) {
                inputs = collectFormInputs(formId);
                if (!inputs) {
                    return; // Validation failed
                }
            }
            
            if (!currentWorkflow) {
                alert('No workflow available to execute');
                return;
            }
            
            try {
                setLoading(true);
                pendingFormExecution = true;
                currentUserInputs = inputs;
                
                // Hide the input form and show execution status
                const userInputSection = document.getElementById('userInputSection');
                if (userInputSection) {
                    userInputSection.style.display = 'none';
                }
                
                addMessageToChat(`🚀 Running workflow "${currentWorkflow.title}" with your inputs...`, 'assistant');
                
                // Execute the workflow with user inputs
                const response = await fetch('/api/execute', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        user_inputs: inputs,
                        form_id: formId 
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('📦 Workflow execution response:', data);
                
                if (data.execution_id) {
                    console.log('✅ Workflow execution started with ID:', data.execution_id);
                    currentExecution = {
                        id: data.execution_id,
                        status: 'running',
                        results: null,
                        start_time: new Date().toISOString()
                    };
                    executionTasks = {};
                    updateExecutionInfo();
                    startRuntimeUpdates();
                } else {
                    throw new Error('No execution ID received');
                }
                
            } catch (error) {
                console.error('❌ Error executing workflow with inputs:', error);
                alert('Failed to execute workflow: ' + error.message);
                pendingFormExecution = false;
            } finally {
                setLoading(false);
            }
        }

        function submitUserInput(formId) {
            console.log('📝 Submitting user input for form:', formId);
            
            const inputField = document.getElementById('user-input-field');
            if (!inputField) {
                alert('Input field not found');
                return;
            }
            
            const userValue = inputField.value;
            if (!userValue || userValue.trim() === '') {
                alert('Please enter a value before submitting');
                return;
            }
            
            console.log('✅ User input collected:', userValue);
            
            // Hide the input form
            const userInputSection = document.getElementById('userInputSection');
            if (userInputSection) {
                userInputSection.style.display = 'none';
            }
            
            // Execute workflow with the collected input
            executeWorkflowWithInputs(formId, { user_input: userValue });
        }

        function detectUserInputFormsInWorkflow(workflow) {
            if (!workflow || !workflow.nodes) return false;
            
            // Check if any agent nodes have user input tools
            const hasUserInputTools = workflow.nodes.some(node => {
                if (node.type === 'agent' && node.data && node.data.tools) {
                    return node.data.tools.some(tool => 
                        tool.includes('user_input')
                    );
                }
                return false;
            });
            
            return hasUserInputTools;
        }

        async function triggerWorkflowForInputs() {
            if (!currentWorkflow) {
                alert('No workflow available to execute');
                return;
            }
            
            console.log('🔄 Triggering workflow to generate input forms...');
            
            try {
                setExecutionLoading(true);
                
                addMessageToChat(`🔄 Preparing workflow "${currentWorkflow.title}" to collect user inputs...`, 'assistant');
                
                // Execute the workflow to generate user input forms
                const response = await fetch('/api/execute', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        execute_current: true
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('📦 Workflow execution response:', data);
                
                if (data.execution_id) {
                    console.log('✅ Workflow execution started with ID:', data.execution_id);
                    currentExecution = {
                        id: data.execution_id,
                        status: 'running',
                        results: null,
                        start_time: new Date().toISOString()
                    };
                    executionTasks = {};
                    updateExecutionInfo();
                    startRuntimeUpdates();
                    
                    addMessageToChat(`✅ Workflow started! Watch for input forms to appear below.`, 'assistant');
                } else {
                    throw new Error('No execution ID received');
                }
                
            } catch (error) {
                console.error('❌ Error triggering workflow for inputs:', error);
                alert('Failed to trigger workflow: ' + error.message);
            } finally {
                setExecutionLoading(false);
            }
        }

        // Cyberpunk Tool Interaction
        // ===========================
        function toggleToolDetails(element) {
            const details = element.querySelector('.tool-details');
            const expand = element.querySelector('.tool-expand');
            
            if (details.style.display === 'none' || !details.style.display) {
                details.style.display = 'block';
                expand.textContent = '▲';
                element.classList.add('expanded');
            } else {
                details.style.display = 'none';
                expand.textContent = '▼';
                element.classList.remove('expanded');
            }
        }

        // Enhanced Text Input Components
        // ==============================

        // UI configurations for text input tools
        const TEXT_INPUT_UI_CONFIGS = {
            "prompt_tool": {
                tool_name: "prompt_tool",
                input_type: "textarea",
                height: "120px",
                min_height: "80px",
                has_run_button: false,
                is_readonly: false,
                placeholder: "Enter your prompt or message...",
                prompt_label: "Prompt Message",
                show_character_count: true,
                supports_collections: true,
                show_suggestions: true,
                show_collection_actions: true,
                max_suggestions: 5
            },
            "user_input": {
                tool_name: "user_input",
                input_type: "textarea", 
                height: "120px",
                min_height: "80px",
                has_run_button: true,
                is_readonly: false,
                placeholder: "Enter your input...",
                prompt_label: "User Input",
                show_character_count: true,
                supports_collections: true,
                show_suggestions: true,
                show_collection_actions: true,
                max_suggestions: 5
            }
        };

        function getTextInputUIConfig(toolName, nodeConfig = {}) {
            if (!TEXT_INPUT_UI_CONFIGS[toolName]) {
                return null;
            }
            
            const config = { ...TEXT_INPUT_UI_CONFIGS[toolName] };
            
            // Override with node-specific config
            if (nodeConfig.placeholder) config.placeholder = nodeConfig.placeholder;
            if (nodeConfig.prompt) config.prompt_label = nodeConfig.prompt;
            if (nodeConfig.height) config.height = nodeConfig.height;
            
            return config;
        }

        function createEnhancedTextInput(nodeId, toolName, nodeConfig, defaultValue = '', suggestions = [], collectionData = null) {
            const uiConfig = getTextInputUIConfig(toolName, nodeConfig);
            if (!uiConfig) {
                // Fallback to regular input for non-enhanced tools
                return createRegularTextInput(nodeId, nodeConfig, defaultValue);
            }

            const textareaId = `enhanced-textarea-${nodeId}`;
            const charCountId = `char-count-${nodeId}`;
            const suggestionsId = `suggestions-${nodeId}`;
            
            // Build suggestions HTML
            let suggestionsHTML = '';
            if (uiConfig.show_suggestions && suggestions && suggestions.length > 0) {
                const limitedSuggestions = suggestions.slice(0, uiConfig.max_suggestions || 5);
                suggestionsHTML = `
                    <div class="suggestions-container" id="${suggestionsId}">
                        <div class="suggestions-header">
                            <span class="suggestions-title">💡 Suggestions</span>
                            ${collectionData ? `<span class="suggestions-source">from ${collectionData.name}</span>` : ''}
                        </div>
                        <div class="suggestions-list">
                            ${limitedSuggestions.map((suggestion, index) => `
                                <div class="suggestion-item" onclick="applySuggestion('${textareaId}', '${charCountId}', '${suggestion.replace(/'/g, "\\'")}', '${nodeId}')">
                                    <span class="suggestion-text">${suggestion}</span>
                                    <span class="suggestion-apply">Apply</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            return `
                <div class="enhanced-text-input-container">
                    <label class="enhanced-input-label">${uiConfig.prompt_label}</label>
                    
                    ${suggestionsHTML}
                    
                    <div class="enhanced-textarea-wrapper">
                        <textarea 
                            id="${textareaId}"
                            name="${nodeId}"
                            class="enhanced-textarea"
                            placeholder="${uiConfig.placeholder}"
                            style="height: ${uiConfig.height}; min-height: ${uiConfig.min_height};"
                            ${uiConfig.is_readonly ? 'readonly' : ''}
                            oninput="updateCharacterCount('${textareaId}', '${charCountId}'); cacheUserInputDual('${nodeId}', '${nodeId}', this.value)"
                            onchange="cacheUserInputDual('${nodeId}', '${nodeId}', this.value)"
                        >${defaultValue}</textarea>
                        ${uiConfig.show_character_count ? `
                            <div class="textarea-footer">
                                <span class="char-count" id="${charCountId}">0 characters</span>
                                ${uiConfig.show_collection_actions ? `
                                    <div class="collection-actions">
                                        <button class="collection-action-btn" onclick="saveToCollection('${nodeId}', '${textareaId}')" title="Save to collection">
                                            💾
                                        </button>
                                        <button class="collection-action-btn" onclick="searchCollections('${nodeId}', '${textareaId}')" title="Search collections">
                                            🔍
                                        </button>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                    ${uiConfig.has_run_button ? `
                        <button class="enhanced-run-button" onclick="submitAndRunWorkflow('${nodeId}')">
                            <span class="icon">▶</span>
                            Run Workflow
                        </button>
                    ` : ''}
                </div>
            `;
        }

        function createRegularTextInput(nodeId, nodeConfig, defaultValue = '') {
            // Fallback for non-enhanced tools
            return `
                <div class="form-field">
                    <label>${nodeConfig.prompt || 'Enter your input:'}</label>
                    <textarea 
                        id="user-input-field"
                        name="${nodeId}"
                        placeholder="${nodeConfig.placeholder || 'Type here...'}"
                        style="min-height: 80px;"
                        oninput="cacheUserInputDual('${nodeId}', '${nodeId}', this.value)"
                        onchange="cacheUserInputDual('${nodeId}', '${nodeId}', this.value)"
                    >${defaultValue}</textarea>
                </div>
            `;
        }

        function updateCharacterCount(textareaId, charCountId) {
            const textarea = document.getElementById(textareaId);
            const charCount = document.getElementById(charCountId);
            
            if (textarea && charCount) {
                const length = textarea.value.length;
                charCount.textContent = `${length} character${length !== 1 ? 's' : ''}`;
            }
        }

        function isTextInputTool(toolName) {
            return TEXT_INPUT_UI_CONFIGS.hasOwnProperty(toolName);
        }

        // Initialize character counts after DOM updates
        function initializeCharacterCounts() {
            document.querySelectorAll('.enhanced-textarea').forEach(textarea => {
                const textareaId = textarea.id;
                const charCountId = textareaId.replace('enhanced-textarea-', 'char-count-');
                updateCharacterCount(textareaId, charCountId);
            });
        }

        // Collection-related functions
        function applySuggestion(textareaId, charCountId, suggestion, nodeId) {
            const textarea = document.getElementById(textareaId);
            if (textarea) {
                textarea.value = suggestion;
                updateCharacterCount(textareaId, charCountId);
                cacheUserInputDual(nodeId, nodeId, suggestion);
                
                // Hide suggestions after applying
                const suggestionsContainer = document.getElementById(`suggestions-${nodeId}`);
                if (suggestionsContainer) {
                    suggestionsContainer.style.display = 'none';
                }
                
                console.log('✅ Applied suggestion:', suggestion);
            }
        }

        async function saveToCollection(nodeId, textareaId) {
            const textarea = document.getElementById(textareaId);
            if (!textarea) {
                alert('Cannot find text input field');
                return;
            }
            
            const collectionName = prompt('Enter collection name (will create if doesn\'t exist):');
            if (!collectionName) return;
            
            const text = textarea.value;
            
            // Show loading state
            const saveBtn = document.querySelector(`[onclick="saveToCollection('${nodeId}', '${textareaId}')"]`);
            let originalText = '💾';
            if (saveBtn) {
                originalText = saveBtn.textContent;
                saveBtn.textContent = '⏳';
                saveBtn.style.color = '#FFA500';
            }
            
            try {
                // Make API call to save to collection
                const response = await fetch('/api/save_to_collection', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        collection_name: collectionName,
                        record: text,
                        tool_type: 'prompt_tool'
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Save request failed');
                }
                
                const data = await response.json();
                console.log('💾 Save result:', data);
                
                if (data.success) {
                    // Show success feedback
                    if (saveBtn) {
                        saveBtn.textContent = '✅';
                        saveBtn.style.color = '#4CAF50';
                    }
                    console.log('✅ Successfully saved to collection:', data.message);
                    
                    // Optional: Show a brief success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: #4CAF50;
                        color: white;
                        padding: 12px 24px;
                        border-radius: 8px;
                        z-index: 1000;
                        font-size: 14px;
                    `;
                    successMsg.textContent = data.message;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        document.body.removeChild(successMsg);
                    }, 3000);
                    
                } else {
                    throw new Error(data.error || 'Save failed');
                }
                
            } catch (error) {
                console.error('Save error:', error);
                alert(`Failed to save to collection: ${error.message}`);
                
                // Show error state
                if (saveBtn) {
                    saveBtn.textContent = '❌';
                    saveBtn.style.color = '#FF6B6B';
                }
            }
            
            // Reset button after delay
            setTimeout(() => {
                if (saveBtn) {
                    saveBtn.textContent = originalText;
                    saveBtn.style.color = '#ff6b35';
                }
            }, 2000);
        }

        async function searchCollections(nodeId, textareaId) {
            const query = prompt('Enter search query:');
            if (!query) return;
            
            console.log('🔍 Searching collections for:', query);
            
            try {
                // Make API call to search collections
                const response = await fetch('/api/search_collections', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        query: query,
                        tool_filter: 'prompt_tool' // Filter by current tool type
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Search request failed');
                }
                
                const data = await response.json();
                console.log('🔍 Search results:', data);
                
                if (data.success && data.results && data.results.length > 0) {
                    // Show results in a nice format
                    let resultsText = `Found ${data.results.length} collection(s) with matches for "${query}":\n\n`;
                    
                    data.results.forEach((result, index) => {
                        resultsText += `📁 ${result.collection_name} (${result.matching_records.length} matches):\n`;
                        result.matching_records.forEach((record, recordIndex) => {
                            resultsText += `  ${recordIndex + 1}. "${record}"\n`;
                        });
                        resultsText += '\n';
                    });
                    
                    const selectedRecord = prompt(resultsText + '\nEnter the number of the record you want to use (or cancel):');
                    
                    if (selectedRecord) {
                        const recordNum = parseInt(selectedRecord);
                        if (!isNaN(recordNum) && recordNum > 0) {
                            // Find the selected record
                            let foundRecord = null;
                            let currentIndex = 0;
                            
                            for (const result of data.results) {
                                for (const record of result.matching_records) {
                                    currentIndex++;
                                    if (currentIndex === recordNum) {
                                        foundRecord = record;
                                        break;
                                    }
                                }
                                if (foundRecord) break;
                            }
                            
                            if (foundRecord) {
                                // Apply the selected record to the textarea
                                const textarea = document.getElementById(textareaId);
                                if (textarea) {
                                    textarea.value = foundRecord;
                                    const charCountId = textareaId.replace('enhanced-textarea-', 'char-count-');
                                    updateCharacterCount(textareaId, charCountId);
                                    cacheUserInputDual(nodeId, nodeId, foundRecord);
                                    console.log('✅ Applied search result:', foundRecord);
                                }
                            }
                        }
                    }
                } else {
                    alert(`No results found for "${query}"\n\nTry different search terms or create some collections first.`);
                }
                
            } catch (error) {
                console.error('Search error:', error);
                alert(`Search failed: ${error.message}\n\nMake sure the backend collection API is running.`);
            }
        }

        // Tab Switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Activate selected tab
            if (tabName === 'results') {
                document.querySelector('.tab-button:nth-child(1)').classList.add('active');
                document.getElementById('resultsTab').classList.add('active');
            } else if (tabName === 'logs') {
                document.querySelector('.tab-button:nth-child(2)').classList.add('active');
                document.getElementById('logsTab').classList.add('active');
            } else if (tabName === 'prompts') {
                document.querySelector('.tab-button:nth-child(3)').classList.add('active');
                document.getElementById('promptsTab').classList.add('active');
                loadPrompts(); // Load prompts when tab is activated
            }
        }
        
        // Load prompts from the server
        async function loadPrompts() {
            try {
                const response = await fetch('/api/prompts');
                const data = await response.json();
                const prompts = data.prompts || []; // Extract prompts array from response
                
                const container = document.getElementById('promptsContainer');
                
                if (!prompts || prompts.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; color: rgba(255, 130, 40, 0.5); padding: 2rem;">
                            No prompts logged yet. Generate a workflow to see prompt history.
                        </div>
                    `;
                    return;
                }
                
                // Sort prompts by timestamp (newest first)
                prompts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                container.innerHTML = prompts.map(prompt => `
                    <div class="prompt-item" style="
                        background: rgba(255, 255, 255, 0.05); 
                        border: 1px solid rgba(255, 130, 40, 0.2); 
                        border-radius: 8px; 
                        padding: 1rem; 
                        margin-bottom: 1rem; 
                        font-family: 'Courier New', monospace;
                    ">
                        <div class="prompt-header" style="
                            display: flex; 
                            justify-content: space-between; 
                            align-items: center; 
                            margin-bottom: 0.5rem;
                        ">
                            <span class="prompt-type" style="
                                background: rgba(255, 130, 40, 0.2); 
                                color: #ff6b35; 
                                padding: 0.2rem 0.5rem; 
                                border-radius: 4px; 
                                font-size: 0.8rem; 
                                font-weight: bold;
                            ">${prompt.type}</span>
                            <span class="prompt-timestamp" style="
                                color: rgba(255, 130, 40, 0.7); 
                                font-size: 0.8rem;
                            ">${new Date(prompt.timestamp).toLocaleString()}</span>
                        </div>
                        
                        <div class="prompt-content" style="
                            background: rgba(0, 0, 0, 0.3); 
                            padding: 0.75rem; 
                            border-radius: 4px; 
                            margin-bottom: 0.5rem; 
                            max-height: 200px; 
                            overflow-y: auto;
                            white-space: pre-wrap;
                            font-size: 0.85rem;
                            line-height: 1.4;
                        ">${prompt.prompt}</div>
                        
                        ${prompt.response ? `
                            <div class="prompt-response" style="
                                background: rgba(0, 100, 0, 0.1); 
                                border-left: 3px solid #4caf50; 
                                padding: 0.75rem; 
                                margin-top: 0.5rem; 
                                border-radius: 0 4px 4px 0;
                                max-height: 150px; 
                                overflow-y: auto;
                                white-space: pre-wrap;
                                font-size: 0.85rem;
                                line-height: 1.4;
                            ">${prompt.response}</div>
                        ` : ''}
                        
                        ${prompt.metadata && Object.keys(prompt.metadata).length > 0 ? `
                            <div class="prompt-metadata" style="
                                color: rgba(255, 130, 40, 0.6); 
                                font-size: 0.75rem; 
                                margin-top: 0.5rem; 
                                padding-top: 0.5rem; 
                                border-top: 1px solid rgba(255, 130, 40, 0.1);
                            ">
                                Metadata: ${JSON.stringify(prompt.metadata, null, 2)}
                            </div>
                        ` : ''}
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('Failed to load prompts:', error);
                document.getElementById('promptsContainer').innerHTML = `
                    <div style="text-align: center; color: #ff6b6b; padding: 2rem;">
                        Failed to load prompt history. Error: ${error.message}
                    </div>
                `;
            }
        }
        
        // Clear all prompts
        async function clearPrompts() {
            if (!confirm('Are you sure you want to clear all prompt history?')) {
                return;
            }
            
            try {
                const response = await fetch('/api/prompts/clear', { method: 'POST' });
                if (response.ok) {
                    loadPrompts(); // Reload to show empty state
                } else {
                    alert('Failed to clear prompts');
                }
            } catch (error) {
                console.error('Failed to clear prompts:', error);
                alert('Failed to clear prompts: ' + error.message);
            }
        }
        
        // Update execution logs display - Compact Nerd Mode
        function updateExecutionLogs(summary) {
            const logsContainer = document.getElementById('executionLogs');
            if (!logsContainer || !summary) {
                console.log('❌ No logs container or summary:', { logsContainer: !!logsContainer, summary: !!summary });
                return;
            }
            
            console.log('📊 Updating execution logs with summary:', summary);
            console.log('📊 nodes_executed detail:', summary.nodes_executed);
            console.log('📊 performance_metrics:', summary.performance_metrics);
            
            const lines = [];
            const nodesExecuted = summary.nodes_executed || [];
            const nodesSkipped = summary.nodes_skipped || [];
            // Count both 'success' and 'completed' as successful
            const successCount = nodesExecuted.filter(n => n.status === 'success' || n.status === 'completed').length;
            const totalNodes = nodesExecuted.length;
            const skipCount = nodesSkipped.length;
            
            // Compact header with safe field access
            const execId = (summary.execution_id || 'unknown').substring(0, 8);
            const status = summary.status || 'unknown';
            const duration = summary.total_duration_seconds || 0;
            
            lines.push(`<span class="log-dim">─────────────────────────────────────────────────────────────────────</span>`);
            lines.push(`<span class="log-highlight">exec:</span> ${execId} <span class="log-dim">|</span> <span class="${status === 'success' ? 'log-success' : 'log-error'}">${status.toUpperCase()}</span> <span class="log-dim">|</span> <span class="log-metric">${duration.toFixed(2)}s</span> <span class="log-dim">|</span> <span class="log-success">${successCount}/${totalNodes}</span> ok <span class="log-dim">|</span> <span class="log-warning">${skipCount}</span> skip`);
            lines.push(`<span class="log-dim">─────────────────────────────────────────────────────────────────────</span>`);
            lines.push('');
            
            // Node execution trace with safe field access and tool usage tracking
            nodesExecuted.forEach((node, idx) => {
                // Check for both 'success' and 'completed' status
                const isSuccess = node.status === 'success' || node.status === 'completed';
                const statusChar = isSuccess ? '✓' : '✗';
                const statusClass = isSuccess ? 'log-success' : 'log-error';
                const duration = (node.duration_seconds !== null && node.duration_seconds !== undefined) ? `${node.duration_seconds.toFixed(1)}s` : '---';
                const nodeId = node.node_id || node.node_label || `node_${idx + 1}`;
                const nodeType = node.node_type || 'unknown';
                
                // Check for SLA info
                const nodeData = currentWorkflow?.nodes?.find(n => n.id === nodeId);
                const hasSLA = nodeData?.sla?.enforce_usage;
                const slaInfo = hasSLA ? ' <span class="log-highlight">🎯SLA</span>' : '';
                
                // Enhanced tool usage display
                let toolsDisplay = '';
                if (node.tool_usage && node.tool_usage.length > 0) {
                    toolsDisplay = `<span class="log-tools">[${node.tool_usage.join(',')}]</span>`;
                }
                
                let traceLine = `[${String(idx + 1).padStart(2, '0')}] <span class="${statusClass}">${statusChar}</span> <span class="log-node-id">${nodeId}</span><span class="log-dim">(${nodeType})</span> <span class="log-metric">${duration.padStart(5)}</span> ${toolsDisplay}${slaInfo}`;
                
                lines.push(traceLine);
                
                // Add detailed tool usage results - check multiple sources
                let toolUsageDetails = [];
                
                // Try to get tool usage from various sources
                if (node.tool_usage_details && node.tool_usage_details.length > 0) {
                    toolUsageDetails = node.tool_usage_details;
                } else if (executionTasks[nodeId] && executionTasks[nodeId].tool_usage_results) {
                    toolUsageDetails = executionTasks[nodeId].tool_usage_results;
                } else if (node.tool_usage_results) {
                    toolUsageDetails = node.tool_usage_results;
                }
                
                if (toolUsageDetails.length > 0) {
                    toolUsageDetails.forEach(tool => {
                        const toolName = tool.tool_name || 'unknown_tool';
                        const toolArgs = tool.args || tool.tool_args;
                        const toolResult = tool.result || tool.tool_result;
                        const isSuccess = tool.success !== false && !tool.error && toolResult !== undefined;
                        const toolStatus = isSuccess ? '✅' : '❌';
                        
                        // Format result preview
                        let resultPreview = 'no result';
                        if (toolResult) {
                            try {
                                if (typeof toolResult === 'object') {
                                    resultPreview = JSON.stringify(toolResult).substring(0, 80).replace(/\n/g, ' ');
                                } else {
                                    resultPreview = String(toolResult).substring(0, 80).replace(/\n/g, ' ');
                                }
                            } catch (e) {
                                resultPreview = String(toolResult).substring(0, 80).replace(/\n/g, ' ');
                            }
                        }
                        
                        lines.push(`    <span class="log-dim">├─</span> ${toolStatus} <span class="log-tool">${toolName}</span> <span class="log-dim">→</span> <span class="log-result">${resultPreview}</span>`);
                    });
                } else if (node.tool_usage && node.tool_usage.length > 0) {
                    // Fallback: just show tool names if detailed usage not available
                    node.tool_usage.forEach(toolName => {
                        lines.push(`    <span class="log-dim">├─</span> <span class="log-warning">?</span> <span class="log-tool">${toolName}</span> <span class="log-dim">→</span> <span class="log-result">tool executed</span>`);
                    });
                }
                
                // Add compact result/error info  
                if (node.error_message) {
                    lines.push(`    <span class="log-dim">└─</span> <span class="log-error">err: ${node.error_message.substring(0, 80).replace(/\n/g, ' ')}</span>`);
                } else if (node.result_preview) {
                    const preview = node.result_preview.substring(0, 80).replace(/\n/g, ' ');
                    lines.push(`    <span class="log-dim">└─</span> <span class="log-result">${preview}</span>`);
                }
                
                // Add detailed tool usage for agents
                if (nodeType === 'agent' && node.tool_usage_details && node.tool_usage_details.length > 0) {
                    node.tool_usage_details.forEach((toolUsage, toolIdx) => {
                        const toolName = toolUsage.tool_name || 'unknown_tool';
                        const toolStatus = toolUsage.success ? '✓' : '✗';
                        const toolStatusClass = toolUsage.success ? 'log-success' : 'log-error';
                        const toolResult = toolUsage.result ? String(toolUsage.result).substring(0, 60).replace(/\n/g, ' ') : '';
                        
                        let toolLine = `    ├─ <span class="${toolStatusClass}">${toolStatus}</span> <span class="log-warning">${toolName}</span>`;
                        if (toolResult) {
                            toolLine += ` <span class="log-dim">→ ${toolResult}</span>`;
                        }
                        lines.push(toolLine);
                    });
                }
            });
            
            // Skipped nodes on one line
            if (nodesSkipped.length > 0) {
                lines.push('');
                lines.push(`<span class="log-warning">skip:</span> <span class="log-dim">${nodesSkipped.join(', ')}</span>`);
            }
            
            // User inputs compact - show clean text instead of JSON
            if (summary.user_inputs && Object.keys(summary.user_inputs).length > 0) {
                lines.push('');
                const inputs = Object.entries(summary.user_inputs)
                    .map(([k, v]) => {
                        // Extract clean text from user input
                        let cleanValue = '';
                        if (typeof v === 'string') {
                            cleanValue = v.substring(0, 50);
                        } else if (typeof v === 'object' && v !== null && v.user_input) {
                            cleanValue = String(v.user_input).substring(0, 50);
                        } else {
                            cleanValue = JSON.stringify(v).substring(0, 30);
                        }
                        return `${k}:"${cleanValue}${cleanValue.length >= 30 ? '...' : ''}"`;
                    })
                    .join(' ');
                lines.push(`<span class="log-highlight">input:</span> <span class="log-dim">${inputs}</span>`);
            }
            
            // Error summary if present
            if (summary.error_summary) {
                lines.push('');
                lines.push(`<span class="log-error">ERROR:</span> ${summary.error_summary.substring(0, 100).replace(/\n/g, ' ')}`);
            }
            
            // Performance metrics on one line
            if (summary.performance_metrics) {
                lines.push('');
                // Format metrics properly, handling objects
                const formattedMetrics = [];
                for (const [k, v] of Object.entries(summary.performance_metrics)) {
                    if (typeof v === 'object') {
                        // Format objects specially based on key
                        if (k === 'execution_path') {
                            formattedMetrics.push(`execution_order:${v.length}`);
                        } else if (k === 'node_durations') {
                            // Format node durations as a compact string
                            if (v && Object.keys(v).length > 0) {
                                const durations = Object.entries(v).map(([nid, dur]) => `${nid}:${dur}s`).join(',');
                                formattedMetrics.push(`node_durations:[${durations}]`);
                            } else {
                                // If no durations, show empty array
                                formattedMetrics.push(`node_durations:[]`);
                            }
                        } else if (k === 'decision_gated_skips' && Array.isArray(v)) {
                            // Skip array of skip IDs
                            continue;
                        }
                        // Skip other complex objects
                    } else {
                        // Format simple values based on key
                        if (k === 'total_nodes') {
                            formattedMetrics.push(`total_nodes:${v}`);
                        } else if (k === 'executed_nodes_count') {
                            formattedMetrics.push(`executed_nodes_count:${v}`);
                        } else if (k === 'skipped_nodes_count') {
                            formattedMetrics.push(`skipped_nodes_count:${v}`);
                        } else if (k === 'failed_nodes') {
                            formattedMetrics.push(`failed_nodes:${v}`);
                        } else if (k !== 'nodes_total' && k !== 'nodes_executed' && k !== 'nodes_skipped') {
                            // Skip duplicate metrics
                            formattedMetrics.push(`${k}:${v}`);
                        }
                    }
                }
                const metrics = formattedMetrics.join(' ');
                lines.push(`<span class="log-metric">perf:</span> <span class="log-dim">${metrics}</span>`);
            }
            
            lines.push(`<span class="log-dim">─────────────────────────────────────────────────────────────────────</span>`);
            
            // Build the HTML
            const logsHTML = '<div class="execution-logs">' + 
                           lines.map(line => `<div class="log-line">${line}</div>`).join('') +
                           '</div>';
            
            logsContainer.innerHTML = logsHTML;
        }
        
        // Panel Resizer Functionality
        let isResizing = false;
        let startY = 0;
        let startHeight = 350; // Default height
        let minHeight = 150;
        let maxHeight = window.innerHeight - 200;
        
        function initializePanelResizer() {
            const resizer = document.getElementById('panelResizer');
            const bottomPanel = document.getElementById('bottomPanel');
            const flowArea = document.getElementById('flowArea');
            
            if (!resizer || !bottomPanel || !flowArea) return;
            
            resizer.addEventListener('mousedown', function(e) {
                isResizing = true;
                startY = e.clientY;
                startHeight = bottomPanel.offsetHeight;
                
                resizer.classList.add('dragging');
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;
                
                const deltaY = startY - e.clientY;
                let newHeight = startHeight + deltaY;
                
                // Constrain to min/max heights
                newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
                
                // Update panel height
                bottomPanel.style.height = newHeight + 'px';
                
                // Update flex basis to maintain smooth animation
                const totalHeight = window.innerHeight - 120; // Account for padding/margins
                const flowHeight = totalHeight - newHeight - 12; // 12px for resizer
                flowArea.style.flex = `0 0 ${flowHeight}px`;
                
                e.preventDefault();
            });
            
            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    resizer.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', function() {
                maxHeight = window.innerHeight - 200;
                const currentHeight = bottomPanel.offsetHeight;
                if (currentHeight > maxHeight) {
                    bottomPanel.style.height = maxHeight + 'px';
                }
            });
        }
        
        function showBottomPanel() {
            const bottomPanel = document.getElementById('bottomPanel');
            const panelResizer = document.getElementById('panelResizer');
            
            if (bottomPanel && panelResizer) {
                bottomPanel.style.display = 'flex';
                panelResizer.style.display = 'flex';
                
                // Trigger a small animation
                setTimeout(() => {
                    bottomPanel.style.height = startHeight + 'px';
                }, 10);
            }
        }
        
        function hideBottomPanel() {
            const bottomPanel = document.getElementById('bottomPanel');
            const panelResizer = document.getElementById('panelResizer');
            const flowArea = document.getElementById('flowArea');
            
            if (bottomPanel && panelResizer && flowArea) {
                bottomPanel.style.display = 'none';
                panelResizer.style.display = 'none';
                flowArea.style.flex = '1'; // Reset to full height
            }
        }

        // Session Management
        let currentSession = {
            session_id: null,
            chat_mode: true,  // Default to chat mode enabled
            conversation_id: null
        };

        async function initializeSession() {
            try {
                // Check current session status
                const response = await fetch('/api/session/status');
                const sessionData = await response.json();
                
                currentSession = sessionData;
                updateSessionUI();
                
                console.log('📋 Session initialized:', currentSession);
            } catch (error) {
                console.error('❌ Failed to initialize session:', error);
            }
        }

        async function toggleChatMode() {
            try {
                const newChatMode = !currentSession.chat_mode;
                
                const response = await fetch('/api/session/chat-mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: newChatMode })
                });
                
                const sessionData = await response.json();
                currentSession = sessionData;
                updateSessionUI();
                
                console.log(`🔄 Chat mode ${newChatMode ? 'enabled' : 'disabled'}:`, currentSession);
            } catch (error) {
                console.error('❌ Failed to toggle chat mode:', error);
            }
        }

        async function resetSession() {
            try {
                const response = await fetch('/api/session/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const sessionData = await response.json();
                currentSession = sessionData;
                updateSessionUI();
                
                console.log('🔄 Session reset:', currentSession);
                
                // Clear chat messages
                const chatMessages = document.getElementById('chatMessages');
                chatMessages.innerHTML = `
                    <div class="message assistant">
                        <div class="message-bubble">
                            👋 New session started! I'm ready to help you create workflows.
                        </div>
                        <div class="message-time">Just now</div>
                    </div>
                `;
            } catch (error) {
                console.error('❌ Failed to reset session:', error);
            }
        }

        function updateSessionUI() {
            const sessionStatus = document.getElementById('sessionStatus');
            const chatModeToggle = document.getElementById('chatModeToggle');
            const resetSession = document.getElementById('resetSession');
            
            if (currentSession.chat_mode) {
                sessionStatus.innerHTML = `💬 <strong>Chat Mode</strong> <span style="color: #64ff64; font-size: 0.9em;">(Memory: ON)</span> | Session: ${currentSession.session_id ? currentSession.session_id.slice(-8) : 'New'}`;
                chatModeToggle.textContent = '🔄 Disable Memory';
                chatModeToggle.classList.add('active');
            } else {
                sessionStatus.innerHTML = `🔄 <strong>Single Mode</strong> <span style="color: #ff6464; font-size: 0.9em;">(Memory: OFF)</span> | No Session`;
                chatModeToggle.textContent = '💬 Enable Memory';
                chatModeToggle.classList.remove('active');
            }
            
            resetSession.disabled = !currentSession.session_id;
        }

        // 🌟 Dynamic Mouse-Following Shadows for Nodes (DISABLED - CONFLICTS WITH REACT FLOW)
        function initializeMouseShadows() {
            // TEMPORARILY DISABLED - The shadow effect was interfering with React Flow's drag system
            // The transform: translateY() was overriding React Flow's positioning
            // Need to implement this more carefully to avoid conflicts
            console.log('Mouse shadows temporarily disabled to fix node dragging');
            return;
            
            let mouseX = 0, mouseY = 0;
            let isMouseActive = false;
            let isDragging = false;
            
            const flowArea = document.querySelector('.flow-area');
            if (!flowArea) return;
            
            // Listen for React Flow drag events
            flowArea.addEventListener('mousedown', (e) => {
                if (e.target.closest('.react-flow__node')) {
                    isDragging = true;
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Track mouse position over the flow area
            flowArea.addEventListener('mousemove', (e) => {
                if (isDragging) return; // Don't apply shadows while dragging
                
                const rect = flowArea.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                isMouseActive = true;
                
                updateNodeShadows();
            });
            
            // Reset shadows when mouse leaves
            flowArea.addEventListener('mouseleave', () => {
                isMouseActive = false;
                resetNodeShadows();
            });
            
            function updateNodeShadows() {
                if (!isMouseActive || isDragging) return;
                
                const nodes = document.querySelectorAll('.react-flow__node');
                
                nodes.forEach(node => {
                    // Skip if node is currently being dragged
                    if (node.classList.contains('react-flow__node-selected')) return;
                    
                    const rect = node.getBoundingClientRect();
                    const flowRect = flowArea.getBoundingClientRect();
                    
                    // Get node center relative to flow area
                    const nodeCenterX = (rect.left + rect.width/2) - flowRect.left;
                    const nodeCenterY = (rect.top + rect.height/2) - flowRect.top;
                    
                    // Calculate distance and direction from mouse to node center
                    const deltaX = nodeCenterX - mouseX;
                    const deltaY = nodeCenterY - mouseY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Max influence distance and shadow distance
                    const maxInfluence = 300; // pixels
                    const maxShadowDistance = 15; // REDUCED from 25
                    
                    if (distance < maxInfluence) {
                        // Calculate shadow intensity (closer = stronger)
                        const intensity = Math.max(0, (maxInfluence - distance) / maxInfluence);
                        
                        // Calculate shadow direction (opposite of light source)
                        const shadowX = (deltaX / distance) * maxShadowDistance * intensity;
                        const shadowY = (deltaY / distance) * maxShadowDistance * intensity;
                        
                        // Apply dynamic shadow - ONLY box-shadow, NO transform
                        const shadowBlur = 10 + (intensity * 15); // REDUCED
                        const shadowOpacity = 0.2 + (intensity * 0.3); // REDUCED
                        
                        // Cyberpunk colors: violet undertones with darker main shadow
                        node.style.boxShadow = `
                            ${shadowX}px ${shadowY}px ${shadowBlur}px rgba(0, 0, 0, ${shadowOpacity}),
                            ${shadowX * 0.5}px ${shadowY * 0.5}px ${shadowBlur * 0.6}px rgba(138, 43, 226, ${intensity * 0.15}),
                            0 4px 16px rgba(138, 43, 226, 0.15),
                            inset 0 1px 0 rgba(255, 255, 255, 0.1),
                            0 0 20px rgba(138, 43, 226, 0.08)
                        `;
                        
                        // DO NOT MODIFY TRANSFORM - Let React Flow handle positioning
                    }
                });
            }
            
            function resetNodeShadows() {
                const nodes = document.querySelectorAll('.react-flow__node');
                nodes.forEach(node => {
                    // Reset ONLY box-shadow and filter, NOT transform
                    node.style.boxShadow = '';
                    node.style.filter = '';
                });
            }
            
            // Throttle for performance
            let animationFrameId;
            const originalUpdateNodeShadows = updateNodeShadows;
            updateNodeShadows = () => {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(originalUpdateNodeShadows);
            };
        }
        
        // Conversation Management
        let currentConversation = null;
        
        async function initializeConversationManager() {
            console.log('📋 Initializing conversation manager...');
            
            // Add event listeners
            document.getElementById('conversationManagerBtn').addEventListener('click', openConversationManager);
            document.getElementById('closeConversationModal').addEventListener('click', closeConversationManager);
            document.getElementById('newConversationBtn').addEventListener('click', createNewConversation);
            document.getElementById('refreshConversationsBtn').addEventListener('click', loadConversations);
            
            // Load current conversation info
            await loadCurrentConversation();
        }
        
        async function loadCurrentConversation() {
            try {
                const response = await fetch('/api/conversations/active');
                const conversation = await response.json();
                currentConversation = conversation;
                updateConversationDisplay(conversation);
            } catch (error) {
                console.error('Error loading current conversation:', error);
                document.getElementById('conversationInfo').textContent = 'Error loading conversation';
            }
        }
        
        function updateConversationDisplay(conversation) {
            const info = document.getElementById('conversationInfo');
            const created = new Date(conversation.created_at).toLocaleDateString();
            const version = conversation.version;
            const stats = `${conversation.workflow_count}w, ${conversation.execution_count}e`;
            
            info.innerHTML = `
                <span style="color: #64ff64;">📋 ${version}</span> • 
                <span style="color: #888;">Created: ${created}</span> • 
                <span style="color: #ff6b35;">${stats}</span>
            `;
        }
        
        function openConversationManager() {
            document.getElementById('conversationModal').style.display = 'flex';
            loadConversations();
        }
        
        function closeConversationManager() {
            document.getElementById('conversationModal').style.display = 'none';
        }
        
        async function loadConversations() {
            const listDiv = document.getElementById('conversationsList');
            listDiv.innerHTML = '<div style="text-align: center; padding: 2rem; color: #888;">Loading conversations...</div>';
            
            try {
                const response = await fetch('/api/conversations');
                const data = await response.json();
                const conversations = data.conversations;
                
                if (conversations.length === 0) {
                    listDiv.innerHTML = '<div style="text-align: center; padding: 2rem; color: #888;">No conversations found</div>';
                    return;
                }
                
                listDiv.innerHTML = conversations.map(conv => {
                    try {
                        const created = new Date(conv.created_at).toLocaleDateString();
                        const lastUsed = new Date(conv.last_used_at).toLocaleDateString();
                        const isActive = currentConversation && conv.conversation_id === currentConversation.conversation_id;
                    const statusColor = {
                        'active': '#64ff64',
                        'archived': '#888',
                        'corrupted': '#ff6666'
                    }[conv.status] || '#888';
                    
                    return `
                        <div class="conversation-item" style="
                            border: 1px solid rgba(255, 255, 255, 0.1);
                            border-radius: 8px;
                            padding: 1rem;
                            margin-bottom: 0.5rem;
                            background: ${isActive ? 'rgba(100, 255, 100, 0.1)' : 'rgba(0, 0, 0, 0.3)'};
                            ${isActive ? 'border-color: #64ff64;' : ''}
                        ">
                            <div style="display: flex; justify-content: between; align-items: flex-start; gap: 1rem;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: ${statusColor}; margin-bottom: 0.25rem;">
                                        ${isActive ? '✅ ' : ''}${conv.version} 
                                        <span style="color: ${statusColor}; font-size: 0.8rem;">
                                            (${conv.status})
                                        </span>
                                    </div>
                                    <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem;">
                                        ID: ${conv.conversation_id.substring(0, 40)}...
                                    </div>
                                    <div style="font-size: 0.75rem; color: #666;">
                                        Created: ${created} • Last used: ${lastUsed}
                                    </div>
                                    <div style="font-size: 0.75rem; color: #666;">
                                        📊 ${conv.total_messages}m • ${conv.workflow_count}w • ${conv.execution_count}e
                                    </div>
                                    ${conv.notes ? `<div style="font-size: 0.7rem; color: #555; margin-top: 0.25rem; font-style: italic;">${conv.notes}</div>` : ''}
                                </div>
                                <div style="display: flex; flex-direction: column; gap: 0.25rem;">
                                    ${conv.status === 'active' && !isActive ? `
                                        <button onclick="switchToConversation('${conv.conversation_id}')" 
                                                style="padding: 0.25rem 0.5rem; font-size: 0.7rem; background: #64ff64; color: #000; border: none; border-radius: 4px; cursor: pointer;">
                                            Switch
                                        </button>
                                    ` : ''}
                                    ${conv.status === 'active' ? `
                                        <button onclick="archiveConversation('${conv.conversation_id}')" 
                                                style="padding: 0.25rem 0.5rem; font-size: 0.7rem; background: #666; color: #fff; border: none; border-radius: 4px; cursor: pointer;">
                                            Archive
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                    } catch (error) {
                        console.error('Error processing conversation:', conv.conversation_id, error);
                        return `<div style="color: #ff6666; padding: 1rem;">Error loading conversation ${conv.conversation_id}</div>`;
                    }
                }).join('');
                
            } catch (error) {
                console.error('Error loading conversations:', error);
                listDiv.innerHTML = '<div style="text-align: center; padding: 2rem; color: #ff6666;">Error loading conversations</div>';
            }
        }
        
        async function createNewConversation() {
            try {
                const response = await fetch('/api/conversations/new', { method: 'POST' });
                const data = await response.json();
                
                if (data.status === 'created') {
                    console.log('✅ Created new conversation:', data.conversation_id);
                    await loadCurrentConversation();
                    await loadConversations();
                    closeConversationManager();
                    
                    // Clear chat messages for fresh start
                    const chatMessages = document.getElementById('chatMessages');
                    chatMessages.innerHTML = `
                        <div class="message assistant">
                            <div class="message-bubble">
                                👋 Hello! I'm your IO.net AI workflow design assistant. Tell me what kind of workflow you'd like to create and I'll help you build it!
                            </div>
                            <div class="message-time">Just now</div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error creating new conversation:', error);
                alert('Error creating new conversation');
            }
        }
        
        async function archiveConversation(conversationId) {
            if (!confirm('Archive this conversation? It will no longer be active but can still be viewed.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/conversations/${conversationId}/archive`, { method: 'POST' });
                const data = await response.json();
                
                if (data.status === 'archived') {
                    console.log('📦 Archived conversation:', conversationId);
                    await loadConversations();
                    
                    // If we archived the current conversation, create a new one
                    if (currentConversation && currentConversation.conversation_id === conversationId) {
                        await createNewConversation();
                    }
                }
            } catch (error) {
                console.error('Error archiving conversation:', error);
                alert('Error archiving conversation');
            }
        }
        
        function switchToConversation(conversationId) {
            // For now, just refresh the page with a note that conversation switching
            // would require reloading the conversation context
            alert('Conversation switching requires a page refresh. This feature will be enhanced in future versions.');
            closeConversationManager();
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 DOM loaded, initializing...');
            debugLibraries();
            initWebSocket();
            loadTools();
            loadExamples();
            updateButtons();
            initializeChatInterface();
            initializeToolSearch();
            initializeEventListeners();
            initializePanelResizer();
            initializeSession();
            initializeMouseShadows();
            
            // Initialize conversation management
            initializeConversationManager();
            
            // Add session control event listeners
            document.getElementById('chatModeToggle').addEventListener('click', toggleChatMode);
            document.getElementById('resetSession').addEventListener('click', resetSession);
            
            console.log('✅ Initialization complete');
        });
    </script>
</body>
</html>