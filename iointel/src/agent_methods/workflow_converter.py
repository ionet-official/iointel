"""
Workflow Converter - Transforms LLM-generated WorkflowSpec to executable WorkflowDefinition.

This module provides the bridge between the clean, minimal workflow specifications
generated by the LLM and the rich, executable workflow definitions used by the system.
"""

from typing import Dict, List, Optional

from .data_models.workflow_spec import WorkflowSpec, NodeSpec, EdgeSpec
from .data_models.datamodels import (
    WorkflowDefinition,
    TaskDefinition,
    AgentParams
)
from ..utilities.registries import TOOLS_REGISTRY
from ..utilities.helpers import make_logger

logger = make_logger(__name__)


class WorkflowConverter:
    """Converts LLM-generated WorkflowSpec to system WorkflowDefinition."""
    
    def __init__(
        self,
        default_agents: Optional[List[AgentParams]] = None,
        default_timeout: int = 60,
        default_retries: int = 3,
        default_client_mode: bool = True
    ):
        """
        Initialize the converter with system defaults.
        
        Args:
            default_agents: Default agents to assign to tasks
            default_timeout: Default timeout in seconds
            default_retries: Default number of retries
            default_client_mode: Default client mode setting
        """
        self.default_agents = default_agents or []
        self.default_timeout = default_timeout
        self.default_retries = default_retries
        self.default_client_mode = default_client_mode
    
    def convert(self, spec: WorkflowSpec) -> WorkflowDefinition:
        """
        Convert a WorkflowSpec to WorkflowDefinition.
        
        Args:
            spec: LLM-generated workflow specification
            
        Returns:
            WorkflowDefinition ready for execution
        """
        logger.info(f"Converting WorkflowSpec '{spec.title}' to WorkflowDefinition")
        
        # Convert nodes to tasks
        tasks = self._convert_nodes_to_tasks(spec.nodes, spec.edges)
        
        # Create workflow definition with DAG metadata
        workflow_def = WorkflowDefinition(
            name=spec.title,
            objective=spec.description,
            client_mode=self.default_client_mode,
            agents=self.default_agents,
            tasks=tasks
        )
        
        # Store DAG structure metadata for execution engine
        if tasks:
            # Add DAG metadata to the first task so workflow can detect DAG structure
            first_task = tasks[0]
            if isinstance(first_task, dict):
                # Handle dict-based task
                if 'task_metadata' not in first_task:
                    first_task['task_metadata'] = {}
                first_task['task_metadata']['dag_structure'] = {
                    'nodes': [node.model_dump() for node in spec.nodes],
                    'edges': [edge.model_dump() for edge in spec.edges],
                    'original_spec_id': str(spec.id)
                }
            else:
                # Handle TaskDefinition object
                if first_task.task_metadata is None:
                    first_task.task_metadata = {}
                first_task.task_metadata['dag_structure'] = {
                    'nodes': [node.model_dump() for node in spec.nodes],
                    'edges': [edge.model_dump() for edge in spec.edges],
                    'original_spec_id': str(spec.id)
                }
        
        logger.info(f"Successfully converted workflow with {len(tasks)} tasks and {len(spec.edges)} edges")
        return workflow_def
    
    def _convert_nodes_to_tasks(
        self,
        nodes: List[NodeSpec],
        edges: List[EdgeSpec]
    ) -> List[TaskDefinition]:
        """Convert nodes to task definitions."""
        tasks = []
        
        # Build edge lookup for dependencies
        edge_map = self._build_edge_map(edges)
        
        for node in nodes:
            task = self._convert_node_to_task(node, edge_map.get(node.id, []))
            tasks.append(task)
        
        return tasks
    
    def _convert_node_to_task(
        self,
        node: NodeSpec,
        incoming_edges: List[EdgeSpec]
    ) -> TaskDefinition:
        """Convert a single node to a task definition."""
        # Base task metadata
        task_metadata = {
            "config": node.data.config,
            "ports": {
                "inputs": node.data.ins,
                "outputs": node.data.outs
            }
        }
        
        # Add node-type specific metadata
        if node.type == "tool" and node.data.tool_name:
            task_metadata["tool_name"] = node.data.tool_name
            
            # Validate tool exists
            if node.data.tool_name not in TOOLS_REGISTRY:
                logger.warning(f"Tool '{node.data.tool_name}' not found in registry")
        
        elif node.type == "agent" and node.data.agent_instructions:
            task_metadata["agent_instructions"] = node.data.agent_instructions
        
        elif node.type == "workflow_call" and node.data.workflow_id:
            task_metadata["workflow_id"] = node.data.workflow_id
        
        # Build execution metadata with system defaults
        execution_metadata = {
            "timeout": self.default_timeout,
            "retries": self.default_retries,
            "client_mode": self.default_client_mode
        }
        
        # Add edge conditions if any
        conditions = [edge.data.condition for edge in incoming_edges if edge.data.condition]
        if conditions:
            execution_metadata["preconditions"] = conditions
        
        # Create task definition
        task = TaskDefinition(
            task_id=node.id,
            name=node.label,
            type=node.type,
            objective=f"Execute {node.label}",
            agents=self._get_agents_for_node(node),
            task_metadata=task_metadata,
            execution_metadata=execution_metadata
        )
        
        return task
    
    def _get_agents_for_node(self, node: NodeSpec) -> Optional[List[AgentParams]]:
        """Determine which agents should execute this node."""
        # For agent nodes, we might want specific agent configurations
        if node.type == "agent":
            # Could enhance this to create specific agent configs based on instructions
            return self.default_agents
        
        # Tool nodes typically don't need agents
        if node.type == "tool":
            return None
        
        # Workflow calls might need agents for coordination
        return self.default_agents
    
    def _build_edge_map(self, edges: List[EdgeSpec]) -> Dict[str, List[EdgeSpec]]:
        """Build a map of target node ID to incoming edges."""
        edge_map = {}
        
        for edge in edges:
            if edge.target not in edge_map:
                edge_map[edge.target] = []
            edge_map[edge.target].append(edge)
        
        return edge_map


def spec_to_yaml(spec: WorkflowSpec, **converter_kwargs) -> str:
    """
    Convert a WorkflowSpec to YAML format.
    
    Args:
        spec: The workflow specification to convert
        **converter_kwargs: Arguments passed to WorkflowConverter
        
    Returns:
        YAML string representation
    """
    import yaml
    
    converter = WorkflowConverter(**converter_kwargs)
    workflow_def = converter.convert(spec)
    
    # Convert to dict and dump as YAML
    workflow_dict = workflow_def.model_dump(mode="json")
    return yaml.safe_dump(workflow_dict, sort_keys=False)


def spec_to_definition(
    spec: WorkflowSpec,
    agents: Optional[List[AgentParams]] = None,
    **kwargs
) -> WorkflowDefinition:
    """
    Convenience function to convert WorkflowSpec to WorkflowDefinition.
    
    Args:
        spec: The workflow specification
        agents: Optional agents to assign
        **kwargs: Additional converter arguments
        
    Returns:
        WorkflowDefinition ready for execution
    """
    converter = WorkflowConverter(default_agents=agents, **kwargs)
    return converter.convert(spec)